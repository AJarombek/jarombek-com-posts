<div>
    <p>
        <text>
            Lately I have been reading up on graph databases and their place in the NoSQL data storage
            universe. The graph database I've worked with is Neo4j, which is very easy to get set up.
            I've found the user interface to view graphs and type in queries to be very enjoyable and
            I highly recommend it if you need a graph database solution.
        </text>
    </p>
    <p>
        <text>
            Without going into too much detail, the largest draw to graph databases is storing
            relationships between data and the speed at which you can query related data points (or in
            graph terms nodes/vertices). Relationships are first class citizens in graph databases which
            allows you to query related data by traversing the relationship itself.  This is contrasted
            with a typical relational database solution where you have to find relationships through
            foreign keys or combine two tables of data with a very slow SQL JOIN operation
        </text>
        <sup>1</sup>
        <text>
            .  Our same slow query in a RDBMS (Relational DataBase Management System) is extremely quick
            in a graph database.
        </text>
    </p>
    <p>
        <text>
            One of the first graphs I made in Neo4j represented the county I grew up in -
        </text>
        <a href="https://i.pinimg.com/736x/32/10/06/3210060e2e11b84a497e7b56dac7fbb8--connecticut-ancestry.jpg">
            Fairfield County CT
        </a>
        <text>
            .  The first task on my list was to create a vertex to represent a state - in this case Connecticut.
            In Cypher (the query language used by Neo4j) that is easy!
        </text>
    </p>
    <CodeSnippet language="Cypher">
CREATE (ct:State {name: 'Connecticut'}) RETURN ct
    </CodeSnippet>
    <p>
        <text>We use the </text>
        <code class="jarombek-inline-code">CREATE</code>
        <text> statement to build a vertex and pass it a label </text>
        <code class="jarombek-inline-code">:State</code>
        <text> and a property </text>
        <code class="jarombek-inline-code">name</code>
        <text>
            . The label is used for grouping, in this case all states will have the label
        </text>
        <code class="jarombek-inline-code">:State</code>
        <text>
            . You can also name the vertex along
            with supply additional key-&gt;value information in the vertices properties.
        </text>
    </p>
    <p>
        <text>You can also create multiple vertices from a single</text>
        <code class="jarombek-inline-code">CREATE</code>
        <text> statement. I will utilize this to populate the counties towns and cities:</text>
    </p>
    <CodeSnippet language="Cypher">
        CREATE (:City {name: 'Bridgeport'}),
        (:City {name: 'Danbury'}),
        ...

        CREATE (:Town {name: 'Bethel'}),
        (:Town {name: 'Brookfield'}),
        ...
    </CodeSnippet>
    <p>
        <text>
            Before I create any relationships, I want to make life easier and group together cities and
            towns under one common label. After all they are both considered settlements.
        </text>
    </p>
    <CodeSnippet language="Cypher">
MATCH (s) WHERE s:City OR s:Town SET s:Settlement
    </CodeSnippet>
    <p>
        <text>I introduced some new keywords here. Most important of them is </text>
        <code class="jarombek-inline-code">MATCH</code>
        <text> which queries the database based on some ASCII Art that I pass it. The </text>
        <code class="jarombek-inline-code">(...)</code>
        <text> token represents a node in the database which I assign to variable</text>
        <code class="jarombek-inline-code">s</code>
        <text>
            . So this query says "for each vertex in the database that is a city or town set a new label
            called Settlement". In Neo4j a vertex can have multuple labels so this
        </text>
        <code class="jarombek-inline-code">SET</code>
        <text>operation will not override the old labels.</text>
    </p>
    <p>
        <text>
            Now it is time for the fun part: relationships. Lets create a relationship between all the
            settlements and the state of Connecticut:
        </text>
    </p>
    <CodeSnippet language={"Cypher"}>
MATCH (ct:State), (s:Settlement) MERGE (ct)<-[:IN]-(s)
    </CodeSnippet>
    <p>
        <text>As you likely guessed, the ASCII art for a relationship is </text>
        <code class="jarombek-inline-code">{`<-[:IN]-`}</code>
        <text>
            where the arrow shows the direction of the relationship. We also give the relationship a
            label, in this case
        </text>
        <code class="jarombek-inline-code">:IN</code>
        <text>
            . We could also give a relationship properties just like you would a vertex. This is what I
            meant by 'relationships are first class entities' - they are treated and can be queried just
            like a vertex! This is extremely powerful.
        </text>
    </p>
    <p>
        <text>
            You may have noticied that in this query we match for multiple vertices. In this case, we
            want all the vertices where the label is State or Settlement. Then we create the
            relationship "settlement is in state". Since the only state in the database is
            Connecticut, this simple query will give us the intended result.
        </text>
    </p>
    <p>
        <text>
            For the final step of this graph we want to create relationships between all the
            neighboring towns. This is a long query so I'll just show a snippet (the full code
            for this and the other snippets can be found
        </text>
        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries
        /2017/11-Nov/11-6-Neo4j-Create/Source/neo4j-create.cql">HERE</a>
        <text>):</text>
    </p>
    <CodeSnippet language="Cypher">
        MATCH (greenwich:Settlement {name: 'Greenwich'}),
        (stamford:Settlement {name: 'Stamford'}),
        (newcannan:Settlement {name: 'New Cannan'}),
        (darien:Settlement {name: 'Darien'}),
        ...
        CREATE (greenwich)-[:NEIGHBORS_OF]->(stamford),
        (stamford)-[:NEIGHBORS_OF]->(newcannan),
        (stamford)-[:NEIGHBORS_OF]->(darien),
        ...
    </CodeSnippet>
    <p>
        <text>
            In this code we first want to give variables for all the settlement nodes by their name.
            Then we want to create neighbors relationships between towns that share borders. One thing
            that I questioned when writing this code is 'why cant there be bi-directional
            relationships?' It turns out at the time of this writing Neo4j does not support
            bi-directional relationships. This is because traversing a realtionship takes the same
            amount of time (O(1)) regardless of the direction it is pointing
        </text>
        <sup>2</sup>
        <text>
            . In a case like this one where we will treat the relationships as bi-directional, you can
            just ignore the arrow in
        </text>
        <code class="jarombek-inline-code">MATCH</code>
        <text>
            queries. Below you can see the output of the settlements in the Neo4j user interface:
        </text>
    </p>
    <figure>
        <img src="./assets/jarombek.png"/>
    </figure>
    <p>
        <text>
            I will look further at Neo4j and build off this graph in future discoveries. I hope this
            shows you just how simple it is to build a graph database!
        </text>
    </p>
</div>