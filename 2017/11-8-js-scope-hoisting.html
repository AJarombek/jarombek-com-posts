<div>
<p>
JavaScript has quickly become one of the languages that I use the most (probably second behind Java).
Many people use JavaScript along with one of its many frontend frameworks (JQuery, AngularJS, etc.)
without really knowing how the core language operates.  I don’t want to be one of those people!
</p>
<p>
This will be the first of many discovery posts on JavaScript.  Let’s look at one of the basic concepts
of the language: how variables interact with scope.  By scope I mean the area of a program you can
access a variable (e.g. a variable declared in a function can only be accessed within that function).
You can also think of scope as the execution environment for a line in a program.  The scope is all
the other variables and functions this program line is aware of.  In JavaScript scope can get a bit
tricky.
</p>
<p>
One tricky part is that declared variables in JavaScript get hoisted to the top of their scope.  Let’s
look at a quick code snippet.
</p>
<CodeSnippet language="JavaScript">
var x = 10;
</CodeSnippet>
<p>
For a Java developer like myself when first starting JavaScript I expected an error.  Variable x hasn’t
been declared yet!  However, JavaScript returns <code class="jarombek-inline-code">undefined</code>,
which means the variable has been declared but not initialized a variable.
</p>
<p>
What’s happening is JavaScript splits the statement <code class="jarombek-inline-code">var x = 10</code>
into its declaration and assignment.  It then ‘hoists’ the declaration to the top of the scope (in this
case the global program scope).  Before the call to <code class="jarombek-inline-code">console.info()</code>
there is a line created that contains<code class="jarombek-inline-code">var x;</code>.
Tricky JavaScript!
</p>
<p>
Now if you are using ES6+ and don’t want hoisting you can use the
<code class="jarombek-inline-code">let</code> keyword (replace
<code class="jarombek-inline-code">var</code> with <code class="jarombek-inline-code">let</code> in
the previous example).  Now if you run the code the
<code class="jarombek-inline-code">console.info(x)</code> call will throw an error.
</p>
<p>
Here is one more basic example:
</p>
<CodeSnippet language="JavaScript">
{
    let firstName = "Andy";
    var lastName = "Jarombek";

    console.info(firstName); // Andrew
    console.info(lastName); // Jarombek
}

console.info(lastName); // Jarombek
console.info(firstName); // Reference Error
</CodeSnippet>
<p>
In JavaScript you can define a scope with the <code class="jarombek-inline-code">{ }</code> block.
You can see that the <code class="jarombek-inline-code">let</code> statement is only available within
the block scope while the variable defined with <code class="jarombek-inline-code">var</code> is
exposed to the global scope<sup>1</sup>.  This can be useful when you want to constrain a variable to
one small piece of code.
</p>
<p>
One thing that the <code class="jarombek-inline-code">{ }</code> block behavior made me question was
‘are variables defined in functions available globally?’  The answer is NO (thankfully) so your internally
defined function variables are local and safe.
</p>
<p>
You can check out the code for these examples
<a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2017/11-Nov/
11-8-JS-Scope-Hoisting/Source/scope.js">HERE</a> along with a look at how variables in for loops leak
into the global scope in JavaScript (Yuck! – but there is a solution with
<code class="jarombek-inline-code">let</code>).
</p>
</div>