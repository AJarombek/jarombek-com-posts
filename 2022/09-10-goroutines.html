<div>
<p>
Recently I read <a href="https://www.gopl.io/">The Go Programming Language</a> in hopes to better understand Go and
discover what makes it unique as a language.  One feature of Go that peaked my interest was goroutines.  Goroutines are a
mechanism for achieving concurrency and parallelism in Go programs.  Many programming languages provide libraries for
using multiple threads to achieve concurrency and sometimes even multiple processes, but Go takes a more distinct
approach with goroutines.
</p>
<p>
Goroutines as a means of concurrent programming lead me to ask many questions, all of which I’ll attempt to answer in
this article.  These questions are as follows:
</p>
<ul>
<li><a href="#">What is a goroutine?</a></li>
<li><a href="#">What is the difference between a thread and a goroutine?</a></li>
<li><a href="#">Why does Go use goroutines instead of threads?</a></li>
<li><a href="#">What are channels and how do they relate to goroutines?</a></li>
<li><a href="#">What is the difference between a coroutine and a goroutine?</a></li>
</ul>
<SectionTitle title="What is a goroutine">What is a goroutine?</SectionTitle>
<Definition word="Goroutine">
A goroutine is an activity within a Go program<sup>1</sup>.  Using goroutines, engineers can write concurrent and
parallel programs.  When a Go program starts and calls its <code className="jarombek-inline-code">main()</code> function,
it runs in a <strong>main goroutine</strong><sup>2</sup>.  This is similar in concept to a <strong>main thread</strong>
in languages like Java and Python, although goroutines and threads are distinct entities.  A new goroutine is created
in a Go program using the <code className="jarombek-inline-code">go</code> keyword.  In a program with multiple
goroutines, each goroutine runs concurrently, and if the computer running the program has multiple CPUs or cores,
potentially in parallel.
</Definition>
<p>
As a basic example, the <a href="https://github.com/AJarombek/go-programming/blob/main/goroutines/basic_example/
basic_example.go">following code</a> starts a separate goroutine from the main goroutine of an application.  Both
goroutines simply print text to stdout and exit.
</p>
<CodeSnippet language="Go">
package main

import (
	"fmt"
	"time"
)

func otherGoroutine() {
	fmt.Println("Other Goroutine")
}

func main() {
	go otherGoroutine()

	// Wait a second in the main goroutine to make it more likely
	// for the other goroutine to run until completion
	time.Sleep(1 * time.Second)

	fmt.Println("Main Goroutine")
}
</CodeSnippet>
<p>
One thing to note is when the main goroutine exists (the <code className="jarombek-inline-code">main()</code> function
completes), all other goroutines are forced to exit as well<sup>3</sup>.  Therefore it is possible the child goroutine
is forced to close before it can print its text.  In production code, there are ways to wait until other goroutines
complete.
</p>
<SectionTitle title="What is the difference between a thread and a goroutine">
What is the difference between a thread and a goroutine?
</SectionTitle>
<p>
A <a href="https://jarombek.com/blog/nov-1-2020-python-concurrency#thread">thread</a>, also known as a lightweight
process, is the most basic unit of scheduling on most computers.  In case you want more background information, I wrote
about threads, the difference between concurrency and parallelism, along with other multithreading concepts in a
<a href="https://jarombek.com/blog/nov-1-2020-python-concurrency">previous article on Python</a>.
</p>
<p>
Threads come in two different forms: kernel threads and user threads.
</p>
<ComparisonTable title="Threads">
<ComparisonTableEntry>
<h5 className="jarombek-cte-title">
Kernel Thread
</h5>
<div className="jarombek-cte-body">
<p>
Kernel threads, also known as OS threads, are threads that are managed by the operating system in kernel mode.
Running in Kernel mode allows OS threads to have unrestricted access to the underlying hardware they are run
on<sup>4</sup>.  Kernel threads contain a virtualized processor, stack space, and program state from the process they
run within<sup>5</sup>.  Although kernel threads require operating system support, all modern operating systems support
them<sup>6</sup>.  An example of a kernel thread library is <a href="https://en.wikipedia.org/wiki/Pthreads">
Pthreads</a>.  You can find examples of pthreads in my <a href="https://github.com/AJarombek/
system-programming-prototypes/tree/main/pthreads">system-programming-prototypes</a> repository.
</p>
</div>
</ComparisonTableEntry>
<ComparisonTableEntry>
<h5 className="jarombek-cte-title">
User Thread
</h5>
<div className="jarombek-cte-body">
<p>
A user thread is similar to an OS thread, except it exists in user space and isn’t managed by the operating system.
Instead, user threads are written and managed in code, such as the standard libraries for programming languages.
While they require lots of user space code to implement, the benefits of user threads include fewer expenses from
context switches and more application control<sup>7</sup>.
</p>
</div>
</ComparisonTableEntry>
</ComparisonTable>
<p>
There are multiple threading models for mapping user threads to kernel threads.  In reality, all threads used in
application code are user threads.  However, depending on the threading model, user threads can utilize kernel threads
for their execution strategy (as is the case with the 1:1 threading model) or be dependent on user space code to
handle threading (as is the case with n:1 and n:m threading models).  Knowing the differences between threading
models along with kernel threads and user threads is critical for understanding goroutines.
</p>
<ComparisonTable title="Threading Models">
<ComparisonTableEntry>
<h5 className="jarombek-cte-title">
1:1 (Kernel-Level Threading)
</h5>
<div className="jarombek-cte-body">
<p>
The 1:1 threading model is where every user thread is mapped to a single kernel thread.  Different ways to think of
this threading model is user threads implementing kernel threading functionality, or user threads being a wrapper
around kernel threads.  1:1 Threading is also known as kernel-level threading<sup>7</sup>.  Pthreads is an example of
a library using the 1:1 threading model, which is why I previously described it as an example of a kernel thread.
While its code isn’t strictly in kernel space, every user thread created with pthreads maps directly to a single,
unique kernel thread; user threads and kernel threads in pthreads form a one-to-one relationship.
</p>
<p>
The benefit of 1:1 threading is that kernel threads can be scheduled and run on separate CPUs or cores.  This means
that kernel threads can run in parallel on a multicore or multiprocessor machine.  The downside of 1:1 threading is
that context switches between threads are expensive, and operating systems set a (configurable) limit to the number
of kernel threads that can be created.  For example, on Linux, the maximum number of threads is viewable with the
<code className="jarombek-inline-code">cat /proc/sys/kernel/threads-max</code> command<sup>8</sup>.
</p>
</div>
</ComparisonTableEntry>
<ComparisonTableEntry>
<h5 className="jarombek-cte-title">
N:1 (User-Level Threading)
</h5>
<div className="jarombek-cte-body">
<p>
The n:1 threading model is where multiple user threads are all mapped to a single kernel thread.  N:1 threading is
also known as user-level threading.  Historically, the Java threading library used n:1 threading (known as green
threads), although this system is no longer used<sup>9,10</sup>.
</p>
<p>
The benefits of n:1 threading are less performance costs related to context switching and more control in user space.
However, on modern architectures, it is important for threads to take advantage of multiple cores and processors.
Since the n:1 threading model maps user threads to a single kernel thread, all user-level threads are executed on a
single core and a single processor.  The performance loss of not taking advantage of multiple cores or processors
far outweighs any benefits gained from reducing context switches (on multicore/multiprocessor machines), making N:1
threading a rarely used approach.  Also, the amount of complex user level code needed to maintain user-level threads
is another detriment to n:1 threading.
</p>
</div>
</ComparisonTableEntry>
<ComparisonTableEntry>
<h5 className="jarombek-cte-title">
N:M (Hybrid Threading)
</h5>
<div className="jarombek-cte-body">
<p>
The n:m threading model is where <i>m</i> user threads are mapped to <i>n</i> kernel threads.  N:M threading is also
known as hybrid threading.
</p>
<p>
For example, take a program that implements hybrid threading and distributes 20 user threads to four kernel threads.  If
the computer this program runs on has a four core processor, these four kernel threads can be distributed evenly across the
processing cores, allowing kernel threads to run in parallel.  However, from the appearance of the application,
20 threads were created, not four.
</p>
<p>
Hybrid threading attempts to benefit from both kernel-level threading and user-level threading.  By utilizing kernel
threads, hybrid threads are able to achieve parallelism on multicore or multiprocessor machines.  By utilizing user
threads, hybrid threads reduce the cost of context switches and provide more power to user-space code.  The downside of
hybrid threads is they are complex to implement<sup>11</sup>.
</p>
</div>
</ComparisonTableEntry>
</ComparisonTable>
<p>
Many programming languages utilize kernel-level threads (the 1:1 threading model).  Modern implementations of
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Java threads</a> and
<a href="https://docs.python.org/3/library/threading.html">Python threads</a> utilize kernel threading under the hood
(In Java, this is referred to as native threading)<sup>12,13</sup>.  One differentiating factor for goroutines compared
to Java or Python threads is that Go maps <i>m</i> goroutines to <i>n</i> kernel threads, thus making it follow the
hybrid threading (n:m) model<sup>14</sup>.
</p>
<SectionTitle title="Why does Go use goroutines instead of threads">
Why does Go use goroutines instead of threads?
</SectionTitle>
<p>
After learning that Go uses hybrid threading instead of a more common kernel threading approach, the question I began
to wonder was why?  Go is a much newer language than Java and Python, which were first released in 1996 and 1991,
respectively.  Therefore, Go had the benefit of hindsight when it chose its threading model.  By using hybrid
threading, goroutines (which exist in user space) are able to have custom functionality that makes concurrent code
easier to use and write.  Hybrid threading also reduces the cost of context switching in the scenario where the number
of goroutines is greater than the number of cores and processors in a machine.  This can result in more efficient
concurrent code while still leveraging a machine's architecture for parallelism.
</p>
<p>
While reading Go documentation and <a href="https://www.gopl.io/">The Go Programming Language</a>, writers are quick to
point out that goroutines are not threads.  In many ways, I find it easier to think of goroutines as user threads with
some unique attributes, making them distinct.  One of the biggest differences between goroutines and typical
threads is that threads have a fixed-sized stack space while goroutines have a dynamically-sized stack
space<sup>15</sup>.
</p>
<p>
I believe dynamically-sized stack space is the best feature of goroutines.  Kernel threads have a fixed-size stack
space whose size is architecture dependent, but is often fairly large to prevent a stack overflow.  As I previously
mentioned, there is also a configurable limit to the number of kernel threads on a machine.  This leads to scalability
issues when a program attempts to execute many operations concurrently.
</p>
<SectionTitle title="What are channels and how do they relate to goroutines">
What are channels and how do they relate to goroutines?
</SectionTitle>
<SectionTitle title="What is the difference between a coroutine and a goroutine">
What is the difference between a coroutine and a goroutine?
</SectionTitle>
<SectionTitle title="Conclusions">Conclusions</SectionTitle>
</div>