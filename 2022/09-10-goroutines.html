<div>
<p>
Recently I read <a href="https://www.gopl.io/">The Go Programming Language</a> in hopes to better understand Go and
discover what makes it unique as a language.  One feature of Go that peaked my interest was goroutines.  Goroutines are a
mechanism for achieving concurrency and parallelism in Go programs.  Many programming languages provide libraries for
using multiple threads to achieve concurrency and sometimes even multiple processes, but Go takes a more distinct
approach with goroutines.
</p>
<p>
Goroutines as a means of concurrent programming lead me to ask many questions, all of which I’ll attempt to answer in
this article.  These questions are as follows:
</p>
<ul>
<li><a href="#">What is a goroutine?</a></li>
<li><a href="#">What is the difference between a thread and a goroutine?</a></li>
<li><a href="#">Why does Go use goroutines instead of threads?</a></li>
<li><a href="#">What are channels and how do they relate to goroutines?</a></li>
<li><a href="#">What is the difference between a coroutine and a goroutine?</a></li>
</ul>
<SectionTitle title="What is a goroutine">What is a goroutine?</SectionTitle>
<Definition word="Goroutine">
A goroutine is an activity within a Go program<sup>1</sup>.  Using goroutines, engineers can write concurrent and
parallel programs.  When a Go program starts and calls its <code className="jarombek-inline-code">main()</code> function,
it runs in a <strong>main goroutine</strong><sup>2</sup>.  This is similar in concept to a <strong>main thread</strong>
in languages like Java and Python, although goroutines and threads are distinct entities.  A new goroutine is created
in a Go program using the <code className="jarombek-inline-code">go</code> keyword.  In a program with multiple
goroutines, each goroutine runs concurrently, and if the computer running the program has multiple CPUs or cores,
potentially in parallel.
</Definition>
<p>
As a basic example, the <a href="https://github.com/AJarombek/go-programming/blob/main/goroutines/basic_example/
basic_example.go">following code</a> starts a separate goroutine from the main goroutine of an application.  Both
goroutines simply print text to stdout and exit.
</p>
<CodeSnippet language="Go">
package main

import (
	"fmt"
	"time"
)

func otherGoroutine() {
	fmt.Println("Other Goroutine")
}

func main() {
	go otherGoroutine()

	// Wait a second in the main goroutine to make it more likely
	// for the other goroutine to run until completion
	time.Sleep(1 * time.Second)

	fmt.Println("Main Goroutine")
}
</CodeSnippet>
<p>
One thing to note is when the main goroutine exists (the <code className="jarombek-inline-code">main()</code> function
completes), all other goroutines are forced to exit as well<sup>3</sup>.  Therefore it is possible the child goroutine
is forced to close before it can print its text.  In production code, there are ways to wait until other goroutines
complete.
</p>
<SectionTitle title="What is the difference between a thread and a goroutine">
What is the difference between a thread and a goroutine?
</SectionTitle>
<p>
A <a href="https://jarombek.com/blog/nov-1-2020-python-concurrency#thread">thread</a>, also known as a lightweight
process, is the most basic unit of scheduling on most computers.  In case you want more background information, I wrote
about threads, the difference between concurrency and parallelism, along with other multithreading concepts in a
<a href="https://jarombek.com/blog/nov-1-2020-python-concurrency">previous article on Python</a>.
</p>
<p>
Threads come in two different forms: kernel threads and user threads.
</p>
<ComparisonTable title="Threads">
<ComparisonTableEntry>
<h5 className="jarombek-cte-title">
Kernel Thread
</h5>
<div className="jarombek-cte-body">
<p>
Kernel threads, also known as OS threads, are threads that are managed by the operating system in kernel mode.
Running in Kernel mode allows OS threads to have unrestricted access to the underlying hardware they are run
on<sup>4</sup>.  Kernel threads contain a virtualized processor, stack space, and program state from the process they
run within<sup>5</sup>.  Although kernel threads require operating system support, all modern operating systems support
them<sup>6</sup>.  An example of a kernel thread library is <a href="https://en.wikipedia.org/wiki/Pthreads">
Pthreads</a>.
</p>
</div>
</ComparisonTableEntry>
<ComparisonTableEntry>
<h5 className="jarombek-cte-title">
User Thread
</h5>
<div className="jarombek-cte-body">
<p>
A user thread is similar to an OS thread, except it exists in user space and isn’t managed by the operating system.
Instead, user threads are written and managed in code, such as the standard libraries for programming languages.
While they require lots of user space code to implement, the benefits of user threads include fewer expenses from
context switches and more application control<sup>7</sup>.
</p>
</div>
</ComparisonTableEntry>
</ComparisonTable>
<p>
There are multiple threading models for mapping user threads to kernel threads.  In reality, all threads used in
application code are user threads.  However, depending on the threading model, user threads can utilize kernel threads
for their execution strategy (as is the case with the 1:1 threading model) or be dependent on user space code to
handle threading (as is the case with n:1 and n:m threading models).  Knowing the differences between threading
models along with kernel threads and user threads is critical for understanding goroutines.
</p>
<ComparisonTable title="Threading Models">
<ComparisonTableEntry>
<h5 className="jarombek-cte-title">
1:1 (Kernel-Level Threading)
</h5>
<div className="jarombek-cte-body">
<p>
The 1:1 threading model is where every user thread is mapped to a single kernel thread.  Different ways to think of
this threading model is user threads implementing kernel threading functionality, or user threads being a wrapper
around kernel threads.  1:1 Threading is also known as kernel-level threading<sup>7</sup>.  Pthreads is an example of
a library using the 1:1 threading model, which is why I previously described it as an example of a kernel thread.
While its code isn’t strictly in kernel space, every user thread created with pthreads maps directly to a single,
unique kernel thread; user threads and kernel threads in pthreads form a one-to-one relationship.
</p>
<p>
The benefit of 1:1 threading is that kernel threads can be scheduled and run on separate CPUs or cores.  This means
that kernel threads can run in parallel on a multicore or multiprocessor machine.  The downside of 1:1 threading is
that context switches between threads are expensive, and operating systems set a (configurable) limit to the number
of kernel threads that can be created.  For example, on Linux, the maximum number of threads is viewable with the
<code className="jarombek-inline-code">cat /proc/sys/kernel/threads-max</code> command<sup>8</sup>.
</p>
</div>
</ComparisonTableEntry>
<ComparisonTableEntry>
<h5 className="jarombek-cte-title">
N:1 (User-Level Threading)
</h5>
<div className="jarombek-cte-body">
<p>
The n:1 threading model is where multiple user threads are all mapped to a single kernel thread.  N:1 threading is
also known as user-level threading.  Historically, the Java threading library used n:1 threading (known as green
threads), although this system is no longer used<sup>9,10</sup>.
</p>
<p>
The benefits of N:1 threading are less performance costs related to context switching and more control in user space.
However, on modern architectures, it is important for threads to take advantage of multiple cores and processors.
Since the N:1 threading model maps user threads to a single kernel thread, all user-level threads are executed on a
single core and a single processor.  The performance loss of not taking advantage of multiple cores or processors
far outweighs any benefits gained from reducing context switches (on multicore/multiprocessor machines), making N:1
threading a rarely used approach.  Also, the amount of complex user level code needed to maintain user-level threads
is another detriment to N:1 threading.
</p>
</div>
</ComparisonTableEntry>
<ComparisonTableEntry>
<h5 className="jarombek-cte-title">
N:M (Hybrid Threading)
</h5>
<div className="jarombek-cte-body">
<p>
</p>
</div>
</ComparisonTableEntry>
</ComparisonTable>
<SectionTitle title="Why does Go use goroutines instead of threads">
Why does Go use goroutines instead of threads?
</SectionTitle>
<SectionTitle title="What are channels and how do they relate to goroutines">
What are channels and how do they relate to goroutines?
</SectionTitle>
<SectionTitle title="What is the difference between a coroutine and a goroutine">
What is the difference between a coroutine and a goroutine?
</SectionTitle>
<SectionTitle title="Conclusions">Conclusions</SectionTitle>
</div>