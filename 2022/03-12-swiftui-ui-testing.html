<div>
<p>
In my <a href="https://jarombek.com/blog/feb-28-2022-swiftui-uikit">previous article</a>, I discussed SwiftUI and how to
integrate SwiftUI components into a UIKit application.  SwiftUI is a (relatively) new framework for creating user
interfaces in Apple ecosystem applications.  User interfaces built using SwiftUI are configured completely in code with
Swift.  In this article, I discuss how to UI test SwiftUI views in an iOS application.
</p>
<SectionTitle title="Introduction to UI Testing">Introduction to UI Testing</SectionTitle>
<p>
UI testing is a form of integration test and end to end test where a user interface is tested in a manner similar to
how a user interacts with it.  For example, a UI test may click a button in a user interface, and assert that something
appears on the screen in response to that button click.  I’ve discussed UI testing frameworks such as
<a href="https://jarombek.com/blog/aug-11-2021-cypress-typescript">Cypress</a> and <a href="https://jarombek.com/blog/
jul-26-2021-aws-synthetics-canary">AWS Synthetics Canary Functions (which utilize Selenium and Puppeteer)</a> in prior
articles, both of which are designed for testing web applications.
</p>
<p>
If you are looking for a step by step guide for how to get started with building UI tests in the XCode IDE,
<a href="https://www.hackingwithswift.com/articles/83/how-to-test-your-user-interface-using-xcode">this article</a> is a
good place to start<sup>1</sup>.  If you want to view the UI test code discussed in this article, it is available in my
<a href="https://github.com/AJarombek/saints-xctf-ios/tree/master/SaintsXCTFUITests">saints-xctf-ios</a> repository on
GitHub.
</p>
<SectionTitle title="Writing UI Tests">Writing UI Tests</SectionTitle>
<p>
The application under test is my <a href="https://apps.apple.com/nz/app/saintsxctf/id1298285886?platform=iphone">
SaintsXCTF</a> iOS app, which allows users to log their running exercises.  It was built for my college cross country
and track & field teams.  The page under test is a SwiftUI view that allows users to create exercise logs.  This view is
shown below.
</p>
<InlineImage filename="2-26-22-exercise-log-view.png" paddingTop="true" paddingBottom="true">
</InlineImage>
<p>
In my codebase, there is a <a href="https://github.com/AJarombek/saints-xctf-ios/blob/master/SaintsXCTFUITests/
ExerciseLogUITests.swift">ExerciseLogUITests.swift</a> file which contains the UI tests for the create exercise log
view.  UI tests are outlined with the following Swift code.
</p>
<CodeSnippet language="Swift">
// ExerciseLogUITests.swift

import XCTest

class ExerciseLogUITests: XCTestCase {

    lazy var app = XCUIApplication()

    override func setUpWithError() throws {
        app.launchArguments += ["UI_TESTING"]
        continueAfterFailure = false
    }

    override func tearDownWithError() throws {}

    ...
}
</CodeSnippet>
<p>
The <code className="jarombek-inline-code">ExerciseLogUITests</code> class contains all the UI tests for the create
exercise log view.  It also contains instance variables used in tests and functions that run before and after test
functions.  For example, <code className="jarombek-inline-code">app</code> is a variable of type
<code className="jarombek-inline-code">XCUIApplication</code> which represents the iOS application.
<code className="jarombek-inline-code">app</code> is used extensively in tests to interact with the UI and make
assertions about its appearance.  The function <code className="jarombek-inline-code">setUpWithError()</code> is invoked
before each test function and <code className="jarombek-inline-code">tearDownWithError()</code> is invoked after each
test function.  I don’t use these methods for much, but they can be utilized for elaborate configurations.  Within
<code className="jarombek-inline-code">setUpWithError()</code>, the line
<code className="jarombek-inline-code">app.launchArguments += ["UI_TESTING"]</code> sets the environment for the
application to run within while tests execute. The line <code className="jarombek-inline-code">
continueAfterFailure = false</code> configures test methods to fail fast after they encounter their first error.
</p>
<p>
The remainder of the <code className="jarombek-inline-code">ExerciseLogUITests</code> class contains UI test methods.
Running these methods in XCode causes an iOS device simulator to run, opening the application and running test commands
and assertions.  Let's look at a basic test.
</p>
<CodeSnippet language="Swift">
func testShowsCreateLog() throws {
    app.launch()
    signIn(app: app)

    let tabBar = app.tabBars["Tab Bar"]
    tabBar.buttons["New Log"].tap()

    let scrollViewsQuery = app.scrollViews
    let elementsQuery = scrollViewsQuery.otherElements

    XCTAssert(elementsQuery.staticTexts["Create Exercise Log"].exists)
    XCTAssert(elementsQuery.staticTexts["Average"].exists)
    XCTAssert(elementsQuery.staticTexts["Exercise Name*"].exists)
    XCTAssert(elementsQuery.staticTexts["Location"].exists)
    XCTAssert(elementsQuery.staticTexts["Date*"].exists)
    XCTAssert(elementsQuery.staticTexts["Exercise Type"].exists)
    XCTAssert(elementsQuery.staticTexts["Distance"].exists)
    XCTAssert(elementsQuery.staticTexts["Time"].exists)
    XCTAssert(elementsQuery.staticTexts["Feel"].exists)
    XCTAssert(elementsQuery.staticTexts["Description"].exists)

    XCTAssert(elementsQuery.buttons["Create"].exists)
    XCTAssert(elementsQuery.buttons["Cancel"].exists)
}
</CodeSnippet>
<p>
<code className="jarombek-inline-code">testShowsCreateLog()</code> is a UI test method that asserts all the expected
input elements and buttons in a form exist on a page.  It begins with the method call
<code className="jarombek-inline-code">app.launch()</code>, which launches the application in the device simulator.  It
then invokes a custom helper function <code className="jarombek-inline-code">signIn(app: app)</code>, which signs a test
user into the application.  <code className="jarombek-inline-code">tabBar.buttons["New Log"].tap()</code> navigates to
the create exercise log page that I intend to test by clicking on a button containing the text "New Log".
</p>
<p>
<code className="jarombek-inline-code">testShowsCreateLog()</code> uses a <code className="jarombek-inline-code">
XCTAssert()</code> function to make assertions about the UI.  For example, the assertion
<code className="jarombek-inline-code">XCTAssert(elementsQuery.staticTexts["Distance"].exists)</code> ensures that the
text "Distance" exists on the page.  Meanwhile, <code className="jarombek-inline-code">
XCTAssert(elementsQuery.buttons["Create"].exists)</code> ensures that the page has a button with the text "Create".
This test is very simple, but even more complicated tests use the same building blocks; all tests interact with the UI
and use <code className="jarombek-inline-code">XCTAssert()</code> to make assertions.
</p>
<p>
Let's look at a slightly more complex UI test.
</p>
<CodeSnippet language="Swift">
func testSliderChangesFeel() throws {
    app.launch()
    signIn(app: app)

    let tabBar = app.tabBars["Tab Bar"]
    tabBar.buttons["New Log"].tap()

    let scrollViewsQuery = app.scrollViews
    let elementsQuery = scrollViewsQuery.otherElements
    let feelSlider = elementsQuery.sliders["Feel"]

    XCTAssert(elementsQuery.staticTexts["Average"].exists)

    feelSlider.adjust(toNormalizedSliderPosition: 0.0)
    XCTAssert(elementsQuery.staticTexts["Terrible"].exists)

    feelSlider.adjust(toNormalizedSliderPosition: 0.1)
    XCTAssert(elementsQuery.staticTexts["Very Bad"].exists)

    feelSlider.adjust(toNormalizedSliderPosition: 0.2)
    XCTAssert(elementsQuery.staticTexts["Bad"].exists)

    feelSlider.adjust(toNormalizedSliderPosition: 0.3)
    XCTAssert(elementsQuery.staticTexts["Pretty Bad"].exists)

    feelSlider.adjust(toNormalizedSliderPosition: 0.4)
    XCTAssert(elementsQuery.staticTexts["Mediocre"].exists)

    feelSlider.adjust(toNormalizedSliderPosition: 0.6)
    XCTAssert(elementsQuery.staticTexts["Average"].exists)

    feelSlider.adjust(toNormalizedSliderPosition: 0.7)
    XCTAssert(elementsQuery.staticTexts["Fairly Good"].exists)

    feelSlider.adjust(toNormalizedSliderPosition: 0.8)
    XCTAssert(elementsQuery.staticTexts["Good"].exists)

    feelSlider.adjust(toNormalizedSliderPosition: 0.9)
    XCTAssert(elementsQuery.staticTexts["Great"].exists)

    feelSlider.adjust(toNormalizedSliderPosition: 1.0)
    XCTAssert(elementsQuery.staticTexts["Fantastic"].exists)
}
</CodeSnippet>
<p>
<code className="jarombek-inline-code">testSliderChangesFeel()</code> tests a slider on the create exercise log page.
This slider is used to indicate how an athlete felt while exercising.
</p>
<InlineImage filename="3-12-22-feel-slider.gif" paddingTop="true" paddingBottom="true">
</InlineImage>
<p>
<code className="jarombek-inline-code">testSliderChangesFeel()</code> starts off the same as the previous test.  It
launches the application (<code className="jarombek-inline-code">app.launch()</code>), signs in a test user
(<code className="jarombek-inline-code">signIn(app: app)</code>), and navigates to the create exercise log page
(<code className="jarombek-inline-code">buttons["New Log"].tap()</code>).  <code className="jarombek-inline-code">
testSliderChangesFeel()</code> is a bit more complex than the previous test because it interacts with the page along
with making assertions.  Method invocations to <code className="jarombek-inline-code">
feelSlider.adjust(toNormalizedSliderPosition: _)</code> move the slider to different positions.  Then,
<code className="jarombek-inline-code">XCTAssert()</code> checks that text displaying how the athlete felt is displayed
on the screen.
</p>
<p>
Let's look at one more UI test.
</p>
<CodeSnippet language="Swift">
func testNameFormValidation() throws {
    app.launch()
    signIn(app: app)

    let tabBar = app.tabBars["Tab Bar"]
    tabBar.buttons["New Log"].tap()

    let scrollViewsQuery = app.scrollViews
    let elementsQuery = scrollViewsQuery.otherElements

    let nameField = elementsQuery.textFields["Name Field"]
    let nameValidationText = elementsQuery.staticTexts["Name Validation Text"]

    XCTAssertEqual(nameField.value as? String, "")
    XCTAssertFalse(nameValidationText.exists)

    nameField.tap()
    nameField.typeText("5th Ave Mile")

    XCTAssertEqual(nameField.value as? String, "5th Ave Mile")
    XCTAssertFalse(nameValidationText.exists)

    nameField.typeText(String(repeating: XCUIKeyboardKey.delete.rawValue, count: 12))
    XCTAssertEqual(nameField.value as? String, "")
    XCTAssert(nameValidationText.exists)

    nameField.typeText("A")
    XCTAssertEqual(nameField.value as? String, "A")
    XCTAssertFalse(nameValidationText.exists)

    nameField.typeText(String(repeating: XCUIKeyboardKey.delete.rawValue, count: 1))
    XCTAssertEqual(nameField.value as? String, "")
    XCTAssert(nameValidationText.exists)
}
</CodeSnippet>
<p>
<code className="jarombek-inline-code">testNameFormValidation()</code> tests that form validation is functional for an
input field on the create exercise log page.  The test types text into a "Name Field" and then deletes it, asserting
that a validation message appears when the text is gone.
</p>
<InlineImage filename="3-12-22-input-validation.gif" paddingTop="true" paddingBottom="true">
</InlineImage>
<p>
Again, this test starts the same as the previous two.  Once on the create exercise log page, two new assertion functions
are used - <code className="jarombek-inline-code">XCTAssertEqual()</code> and <code className="jarombek-inline-code">
XCTAssertFalse()</code>.  Like any other testing library, XCTest provides many different assertion functions to make
testing easier.  <code className="jarombek-inline-code">XCTAssertEqual(nameField.value as? String, "")</code> checks
that the "Name" field is empty when the page first loads, and <code className="jarombek-inline-code">
XCTAssertFalse(nameValidationText.exists)</code> checks that no validation text is shown when the page first loads.
</p>
<p>
<code className="jarombek-inline-code">nameField.typeText("5th Ave Mile")</code> types a value into the "Name" field.
Assertions follow which ensure that the text typed is displayed on the screen.  The text is then deleted by passing
<code className="jarombek-inline-code">String(repeating: XCUIKeyboardKey.delete.rawValue, count: 12)</code> to
<code className="jarombek-inline-code">nameField.typeText()</code>.  The assertion <code className="jarombek-inline-code">
XCTAssert(nameValidationText.exists)</code> ensures that the validation message is properly displayed.
</p>
<SectionTitle title="Writing UI Tests with Network Stubs">Writing UI Tests with Network Stubs</SectionTitle>
<SectionTitle title="Conclusions">Conclusions</SectionTitle>
</div>
