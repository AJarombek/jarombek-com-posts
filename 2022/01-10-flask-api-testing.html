<div>
<Note type="info">
This is part of a series of articles on SaintsXCTF Version 2.0. The first article in the series provides an
<a href="https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview">overview of the application</a>.  You
<strong>DO NOT</strong> need to read prior articles in the series to fully understand this article.
</Note>
<p>
In a <a href="https://jarombek.com/blog/jan-2-2022-s3-restrict-access">prior article</a>, I discussed my Flask API
written for <a href="https://saintsxctf.com/">SaintsXCTF</a>, an application which allows users and their teammates to
log running exercises and keep track of their running mileage.  As with any piece of software, this Flask API requires
extensive testing to keep it functional and maintainable.  In this article, I discuss the automated testing approach I
implemented for the API.
</p>
<SubTitle title="SaintsXCTF Version 2.0 Articles">SaintsXCTF Version 2.0 Articles</SubTitle>
<ul>
<li><a href="https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview">Architectural Overview</a></li>
<li><a href="https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview">AWS Infrastructure</a></li>
<li><a href="https://jarombek.com/blog/oct-25-2021-saints-xctf-v2-k8s-infrastructure">Kubernetes Infrastructure</a></li>
<li><a href="https://jarombek.com/blog/nov-1-2021-saints-xctf-v2-react-web-app">React Web Application Overview</a></li>
<li><a href="https://jarombek.com/blog/nov-15-2021-react-typescript">Web Application React and TypeScript</a></li>
<li><a href="https://jarombek.com/blog/dec-3-2021-redux-react">Web Application Redux State Configuration</a></li>
<li><a href="https://jarombek.com/blog/aug-11-2021-cypress-typescript">Web Application Cypress E2E Tests</a></li>
<li><a href="https://jarombek.com/blog/jun-30-2021-react-jss">Web Application JSS Modular Design</a></li>
<li><a href="https://jarombek.com/blog/dec-24-2021-flask-python-api">Flask Python API</a></li>
<li><strong>Flask API Testing</strong></li>
<li>Flask API Docker & Docker Compose Configuration</li>
<li>Function API Using API Gateway & Lambda</li>
<li>Auth API Using API Gateway & Lambda</li>
<li>Database Deployments Using Jenkins</li>
<li>Database Client on Kubernetes</li>
<li>Testing and Continuous Deployment on Jenkins</li>
</ul>
<SectionTitle title="Configuring Automated Tests">Configuring Automated Tests</SectionTitle>
<p>
The tests for my application use the built-in Python <strong>unittest</strong> library, along with the
<strong>coverage</strong> library for code coverage.  Code coverage determines which lines of the API source code are
covered by tests, allowing me to find gaps in testing.  The <strong>coverage</strong> library shows both textual and
HTML reports of code coverage, making it extremely easy to drill down into specific source files and find which lines
of code aren't being tested.
</p>
<p>
In the Flask application source code, I created a custom CLI command which triggers the <strong>unittest</strong> tests
with code coverage enabled.  This way, application tests are triggered from the command line with a
<code className="jarombek-inline-code">flask test</code> command.  In Flask code, the CLI command is a Python
function <code className="jarombek-inline-code">test()</code>, located within a <a href="https://github.com/AJarombek/
saints-xctf-api/blob/v2.0.1/api/src/commands.py#L20-L46">commands.py</a> file.  <code className="jarombek-inline-code">
test()</code> is added to the Flask application in my <a href="https://github.com/AJarombek/saints-xctf-api/blob/
v2.0.1/api/src/app.py#L61">app.py</a> file with the following line:
</p>
<CodeSnippet language="Python">
application.cli.add_command(test)
</CodeSnippet>
<p>
<code className="jarombek-inline-code">test()</code> starts code coverage, runs the tests, and then collects a code
coverage report.  The code is shown below, and is inspired by a function found in the book
<a href="https://www.oreilly.com/library/view/flask-web-development/9781491991725/">Flask Web Development</a><sup>1</sup>.
</p>
<CodeSnippet language="Python">
cov = None
if os.environ.get('FLASK_COVERAGE'):
    cov = coverage.coverage(branch=True, include=['app.py', 'dao/*', 'model/*', 'route/*', 'utils/*'])
    cov.start()


@click.command()
@with_appcontext
def test():
    """
    Create a Flask command for running unit tests.  Execute with 'flask test' from a command line.
    """
    if not os.environ.get('FLASK_COVERAGE'):
        os.environ['FLASK_COVERAGE'] = '1'
        os.execvp(sys.executable, [sys.executable] + sys.argv)

    # Create a test runner an execute the test suite
    tests = unittest.TestLoader().discover('tests')
    runner = unittest.TextTestRunner(verbosity=3)
    result: unittest.TestResult = runner.run(tests)

    if cov:
        cov.stop()
        cov.save()
        print('Coverage Summary:')
        cov.report()
        basedir = os.path.abspath(os.path.dirname(__file__))
        cov_dir = os.path.join(basedir, 'tmp/coverage')
        cov.html_report(directory=cov_dir)
        print('HTML version: file://%s/index.html' % cov_dir)
        cov.erase()

    exit(len(result.errors))
</CodeSnippet>
<p>
<code className="jarombek-inline-code">test()</code> runs all the Python files in the <a href="https://github.com/
AJarombek/saints-xctf-api/tree/v2.0.1/api/src/tests">test</a> directory of my application.
</p>
<SectionTitle title="Testing Approach">Testing Approach</SectionTitle>
<p>
Most of the tests in my application invoke API endpoints and assert they return certain HTTP response bodies and
response status codes.  This means that in order for my tests to execute successfully, a running instance of the API is
needed.  Instead of using the API running in production, I use a test API that can be quickly spun up before tests
begin and spun down after tests stop.  All the configuration for this test API and the execution environment for the
tests themselves is accomplished using Docker and Docker Compose.
</p>
<p>
In general, each component of my application backend has a corresponding Docker Compose file.  There is also a Docker
Compose file for the API tests.  These Docker Compose files exist in a <a href="https://github.com/AJarombek/
saints-xctf-api/tree/v2.0.1/infra/docker-compose">docker-compose</a> directory in my repository.
</p>
<p>
There are five Docker Compose files in total, each running a single Docker container.  The four Docker Compose files
that together form my application backend are for the <a href="https://github.com/AJarombek/saints-xctf-api/blob/
v2.0.1/infra/docker-compose/docker-compose-db-local.yml">database</a>, <a href="https://github.com/AJarombek/
saints-xctf-api/blob/v2.0.1/infra/docker-compose/docker-compose-auth-local.yml">authentication API</a>,
<a href="https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/infra/docker-compose/docker-compose-fn-local.yml">
AWS Lambda function API</a>, and <a href="https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/infra/docker-compose/
docker-compose-api-local.yml">main Flask API</a>.  These four Docker Compose configurations need to be started using
the <code className="jarombek-inline-code">docker-compose up</code> command before the API tests are run.  Once they
are running, the <a href="https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/infra/docker-compose/
docker-compose-test-local.yml">API test</a> Docker Compose file can be run.  This Docker Compose file starts a
container, runs the API tests on that container, and then stops the container.
</p>
<CodeSnippet language="YAML">
# docker-compose-test-local.yml

version: '3.7'
services:
  test:
    build:
      context: ../../api/src/
      dockerfile: local.test.dockerfile
      network: host
    networks:
      - local-saints-xctf-api-net

networks:
  local-saints-xctf-api-net:
    driver: bridge
</CodeSnippet>
<p>
This Docker Compose file runs a <a href="https://github.com/AJarombek/saints-xctf-api/blob/v2.0.1/api/src/
local.test.dockerfile">local.test.dockerfile</a> Dockerfile, which has the following configuration:
</p>
<CodeSnippet language="Dockerfile">
FROM python:3.8-alpine

RUN apk update \
    && apk add --virtual .build-deps gcc python3-dev libc-dev libffi-dev g++ \
    && pip install --upgrade pip \
    && pip install pipenv

COPY . /src
WORKDIR /src

RUN pipenv install

ENV FLASK_APP app.py
ENV ENV localtest

COPY credentials .aws/
ENV AWS_DEFAULT_REGION us-east-1
ENV AWS_SHARED_CREDENTIALS_FILE .aws/credentials

ENTRYPOINT ["pipenv", "run", "flask", "test"]
</CodeSnippet>
<p>
At its core, this container uses a <code className="jarombek-inline-code">python:3.8-alpine</code> container as its
base, installs necessary dependencies for the API code, and runs the <code className="jarombek-inline-code">
flask test</code> command in the container <code className="jarombek-inline-code">ENTRYPOINT</code>.  Running this
container shows a console output similar to the following:
</p>
<CodeSnippet>
Starting docker-compose_test_1 ... done
Attaching to docker-compose_test_1
test_1  | test_app_exists (test_src.testApp.TestApp) ... ok
test_1  | test_non_existent_route (test_src.testApp.TestApp)
test_1  | ...
test_1  | test_user_update_last_login_by_username_put_route_unauthorized (test_src.test_route.testUserRoute.TestUserRoute)
test_1  | Test performing an unauthorized HTTP PUT request on the '/v2/users/&lt;username>/update_last_login' route. ... ok
test_1  |
test_1  | ----------------------------------------------------------------------
test_1  | Ran 467 tests in 77.992s
test_1  |
test_1  | OK (skipped=11)
test_1  | Coverage Summary:
test_1  | Name                           Stmts   Miss Branch BrPart  Cover
test_1  | ----------------------------------------------------------------
test_1  | app.py                            73     35      6      0    48%
test_1  | dao/activationCodeDao.py          25      0      0      0   100%
test_1  | dao/basicDao.py                   15      0      0      0   100%
test_1  | dao/userDao.py                    40      3      0      0    92%
test_1  | model/User.py                     75      0      0      0   100%
test_1  | model/UserData.py                 30      2      4      2    88%
test_1  | route/userRoute.py               486     31    138     30    90%
test_1  | utils/exerciseFilters.py          19      2     14      2    88%
test_1  | ...
test_1  | ----------------------------------------------------------------
test_1  | TOTAL                           3625    261    692    154    90%
test_1  | HTML version: file:///src/tmp/coverage/index.html
docker-compose_test_1 exited with code 0
</CodeSnippet>
<p>
This output states that the container started, 467 tests ran in 78 seconds with a successful (OK) status, and the code
coverage of the API is 90%.
</p>
<SectionTitle title="Test Code">Test Code</SectionTitle>
<SectionTitle title="Conclusions">Conclusions</SectionTitle>
</div>