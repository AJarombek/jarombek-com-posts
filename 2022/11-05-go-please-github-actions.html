<div>
<p>
During software development, it’s important to test logic and perform static code analysis to ensure programs meet
certain standards.  Build tools and CI/CD platforms help developers automate these tasks.  There are so many different
build tools, such as Make, <a href="https://jarombek.com/blog?query=Bazel&page=1">Bazel</a>,
<a href="https://jarombek.com/blog?query=Please&page=1">Please</a>, and CI/CD platforms, such as
<a href="https://jarombek.com/blog?query=Jenkins&page=1">Jenkins</a>,
<a href="https://jarombek.com/blog?query=TravisCI&page=1">TravisCI</a>,
<a href="https://jarombek.com/blog?query=GitHub%20Actions&page=1">GitHub Actions</a> (to name a few), that it can
become overwhelming for engineers to pick the best option for their codebase.
</p>
<p>
Although I’ve experimented a bit with TravisCI in the past, most of my CI/CD work up until now has been on Jenkins.
Outside of language or platform specific build tools (such as CMake or Webpack), I haven’t used many language-agnostic
build tools in my code to this point.  While designing my <a href="https://github.com/AJarombek/go-programming">
go-programming</a> repository, a codebase containing Go programming language sample programs, I decided to work with a
new build tool and CI/CD platform.
</p>
<p>
For a build tool, I decided to use <a href="https://please.build/">Please Build</a>, a language agnostic build platform
based on Google’s internal Blaze build tool, which was ported to the open source community as Bazel<sup>1</sup>.  For a
CI/CD platform, I decided to use <a href="https://github.com/features/actions">GitHub Actions</a>, which is built-in to
GitHub.  In this article, I’ll discuss the basics of Please Build and GitHub Actions, along with how I integrated both
into my <a href="https://github.com/AJarombek/go-programming">go-programming</a> repository.
</p>
<SectionTitle title="Repository Overview">Repository Overview</SectionTitle>
<p>
The <a href="https://github.com/AJarombek/go-programming">go-programming</a> repository consists of many subdirectories
containing Go code.  This Go code contains tests that I ensure are successful and libraries that I build and compile
into machine specific binaries.  For example, the <a href="https://github.com/AJarombek/go-programming/tree/v1.1.1/
goroutines">goroutines</a> subdirectory contains test code, such as <a href="https://github.com/AJarombek/
go-programming/blob/v1.1.1/goroutines/basics_test.go">basics_test.go</a>, along with libraries, such as
<a href="https://github.com/AJarombek/go-programming/blob/v1.1.1/goroutines/goroutine_example/goroutine_example.go">
goroutine_example.go</a>.
</p>
<p>
I use the GoLand IDE by Jetbrains for Go development.  One of the great features of Jetbrains IDEs, GoLand included, is
run configurations.  Run configurations enable an easy way to run or test Go code through the GoLand UI<sup>2</sup>.
Run configurations can optionally run on a Docker container, and configurations can be saved and committed to a
repository in XML files.
</p>
<p>
In the <a href="https://github.com/AJarombek/go-programming/tree/v1.1.1">go-programming</a> repository, run
configurations are stored in a <a href="https://github.com/AJarombek/go-programming/tree/v1.1.1/.run">.run</a>
directory.  These run configurations execute on Docker containers, which are defined in a
<a href="https://github.com/AJarombek/go-programming/tree/v1.1.1/base">base</a> directory.  Currently, all my run
configurations execute on docker containers derived from a base <strong>Dockerfile</strong>, which is specified in
<a href="https://github.com/AJarombek/go-programming/blob/v1.1.1/base/Dockerfile">base/Dockerfile</a>, with the
following setup.
</p>
<CodeSnippet language="Dockerfile">
FROM golang:1.18.3-alpine3.16

RUN apk add gcc libc-dev linux-headers

RUN curl https://get.please.build > please.sh && \
    bash ./please.sh

ENV PATH="${PATH}:/root/.please/bin"

STOPSIGNAL SIGTERM
</CodeSnippet>
<p>
The most important thing this base Dockerfile does is install Please Build from the URL <strong>
https://get.please.build</strong> and append its installation directory onto the <code className="jarombek-inline-code">
PATH</code> environment variable.  Go is installed and configured in the <code className="jarombek-inline-code">golang</code>
image, which is specified as the base image using the <code className="jarombek-inline-code">
FROM golang:1.18.3-alpine3.16</code> command.
</p>
<p>
Each subdirectory in the repository has its own Dockerfile, using <a href="https://github.com/AJarombek/go-programming/
blob/v1.1.1/base/Dockerfile">base/Dockerfile</a> as its base image. Subdirectory Dockerfiles contain commands
needed to execute the code within the subdirectory.  For example, the <a href="https://github.com/AJarombek/
go-programming/tree/v1.1.1/goroutines">goroutines</a> subdirectory contains the following <a href="https://github.com/
AJarombek/go-programming/blob/v1.1.1/goroutines/Dockerfile">Dockerfile</a>
</p>
<CodeSnippet language="Dockerfile">
FROM ajarombek/go-alpine-linux-programming:latest

WORKDIR src
COPY . .

ENTRYPOINT ["go", "test", "-v", "."]
</CodeSnippet>
<p>
This Dockerfile uses my base image <code className="jarombek-inline-code">ajarombek/go-alpine-linux-programming:latest
</code>, which is available on <a href="https://hub.docker.com/repository/docker/ajarombek/go-alpine-linux-programming">
DockerHub</a>.  It copies files from my repository onto the containers filesystem and runs the command
<code className="jarombek-inline-code">go test -v .</code>, which executes all the Go tests.
</p>
<p>
This Dockerfile is also used in a run configuration for the repository.  GoLand run configurations are XML files, and
in my repository they simply specify a docker container to run.  For the
<a href="https://github.com/AJarombek/go-programming/tree/v1.1.1/goroutines">goroutines</a> subdirectory, I created a
<a href="https://github.com/AJarombek/go-programming/blob/v1.1.1/.run/goroutines.run.xml">goroutines.run.xml</a> run
configuration which starts a Docker container.
</p>
<CodeSnippet language="XML">
&lt;component name="ProjectRunConfigurationManager">
    &lt;configuration default="false" name="goroutines" type="docker-deploy" factoryName="dockerfile" server-name="Docker">
        &lt;deployment type="dockerfile">
            &lt;settings>
                &lt;option name="containerName" value="go_programming_goroutines" />
                &lt;option name="sourceFilePath" value="goroutines/Dockerfile" />
            &lt;/settings>
        &lt;/deployment>
        &lt;method v="2" />
    &lt;/configuration>
&lt;/component>
</CodeSnippet>
<p>
This run configuration specifies the creation of a Docker image named <code className="jarombek-inline-code">
go_programming_goroutines</code> created using the Dockerfile <code className="jarombek-inline-code">
goroutines/Dockerfile</code>. Putting all the pieces together, the following image shows what it looks like to trigger
the run configuration and view its console log.
</p>
<InlineImage filename="11-5-22-goland-run-config.png" paddingTop="true" paddingBottom="true">
</InlineImage>
<p>
Run configurations are great for manually executing tests or running code.  However, for CI/CD purposes, operations
like executing tests, compiling code, and packaging binaries should be automated.  This is where Please Build and
GitHub Actions can help.
</p>
<SectionTitle title="Please Build Setup">Please Build Setup</SectionTitle>
<Definition word="Please Build">
Please Build is a language agnostic build system derived from Bazel and Blaze, which are open source and proprietary
build systems originating at Google.  Like Bazel and Blaze, Please Build uses the Starlark programming language for its
build files.  Build files, named <strong>BUILD</strong>, contain build targets, which are units of deployable
code<sup>3</sup>.  Build targets are written using rules, which appear as Python functions.  Rules are configurable
using arguments and they determine what occurs when a build target is run.  Builds are run in isolation from
application source code; they are given a separate <strong>plz-out</strong> directory to run it.  Build results are
also cached, which makes subsequent builds on unchanged code very fast.
</Definition>
<Definition word="Starlark Programming Language">
Starlark is a programming language that is syntactically similar to and inspired by Python<sup>4</sup>.  Starlark is
used in <strong>BUILD</strong> files for the Blaze and Bazel build tools, along with their derivatives such as Please
Build.  Starlark has different language rules than Python despite its syntactic similarities;  Starlark is neither a
superset or subset of Python.
</Definition>
<p>
When configuring Please Build in a repository, a <code className="jarombek-inline-code">plz init</code> command is run
from the root of the codebase.  This command creates a <a href="https://github.com/AJarombek/go-programming/blob/
v1.1.1/.plzconfig">.plzconfig</a> file in the repository, which configures the execution of Please
commands<sup>5</sup>.  This is how <a href="https://github.com/AJarombek/go-programming/blob/v1.1.1/.plzconfig">
.plzconfig</a> appears in my <a href="https://github.com/AJarombek/go-programming/tree/v1.1.1">go-programming</a>
repository.
</p>
<CodeSnippet language="TOML">
[please]
version = 16.22.1

[build]
PassEnv = PATH
path = $PATH:/usr/local/bin:/usr/bin:/bin

[buildenv]
test-env = plz
</CodeSnippet>
<p>
<a href="https://github.com/AJarombek/go-programming/blob/v1.1.1/.plzconfig">.plzconfig</a> lists out different build
options to use in the repository<sup>6</sup>.  <code className="jarombek-inline-code">version = 16.22.1</code> sets the
version of Please Build to use while performing builds.  <code className="jarombek-inline-code">PassEnv = PATH</code>
takes the <code className="jarombek-inline-code">PATH</code> environment variable and makes it accessible while Please
Build rules are executed.  <code className="jarombek-inline-code">path = $PATH:/usr/local/bin:/usr/bin:/bin</code> then
takes this path and appends <code className="jarombek-inline-code">/usr/local/bin:/usr/bin:/bin</code> to it.  Finally,
<code className="jarombek-inline-code">test-env = plz</code> creates a new environment variable named
<code className="jarombek-inline-code">TEST_ENV</code> and assigns it a value of <code className="jarombek-inline-code">
plz</code>.  <code className="jarombek-inline-code">TEST_ENV</code> is accessible while running Please Build commands.
These are just a few of the configuration options available with Please Build; a full list of options is available in
the <a href="https://please.build/config.html">Please Build documentation</a>.
</p>
<p>
As previously mentioned, Please Build consists of <strong>BUILD</strong> files written in Starlark.  In my
<a href="https://github.com/AJarombek/go-programming/tree/v1.1.1">go-programming</a> repository, the root directory
contains a <a href="https://github.com/AJarombek/go-programming/blob/v1.1.1/BUILD">BUILD</a> file with the following
contents.
</p>
<CodeSnippet language="Starlark">
package(default_visibility = ["PUBLIC"])

go_toolchain(
    name = "go_download",
    version = "1.18",
)

go_module(
    name = "testify",
    module = "github.com/stretchr/testify",
    install = ["..."],
    version = "v1.7.0",
    deps = [
        ":go_difflib",
        ":go_yaml",
        ":go_spew",
        ":objx",
    ],
)

go_module(
    name = "go_difflib",
    module = "github.com/pmezard/go-difflib",
    install = ["..."],
    version = "v1.0.0",
    deps = [":go_download"],
)

go_module(
    name = "go_yaml",
    module = "gopkg.in/yaml.v3",
    install = ["..."],
    version = "v3.0.0-20200313102051-9f266ea9e77c",
    deps = [":go_download"],
)

go_module(
    name = "go_spew",
    module = "github.com/davecgh/go-spew",
    install = ["..."],
    version = "v1.1.0",
    deps = [":go_download"],
)

go_module(
    name = "objx",
    module = "github.com/stretchr/objx",
    install = ["..."],
    version = "v0.1.0",
    deps = [":go_download"],
)
</CodeSnippet>
<p>
On the first line of code, <code className="jarombek-inline-code">package()</code>, a Please Build built-in function,
sets configuration details for all the ensuing rules<sup>6</sup>.  In my code, it sets the visibility of all the rules
in the file to <code className="jarombek-inline-code">PUBLIC</code>, which makes them accessible to all the other rules
in the repository<sup>7</sup>.
</p>
<p>
The next rule, <code className="jarombek-inline-code">go_toolchain()</code>, downloads Go for other
<code className="jarombek-inline-code">go_</code> prefixed rules to use.  Based on my configurations,
<code className="jarombek-inline-code">go_toolchain()</code> downloads version 1.18 of Go.  The
<code className="jarombek-inline-code">name</code> argument of <code className="jarombek-inline-code">
go_toolchain()</code>, defines a unique name for the rule that can be used as a dependency for other rules.
<code className="jarombek-inline-code">name</code> is considered a common rule, and exists on every rule in Please
Build<sup>8</sup>.
</p>
<SectionTitle title="Enabling GitHub Actions">Enabling GitHub Actions</SectionTitle>
<SectionTitle title="Conclusions">Conclusions</SectionTitle>
</div>
