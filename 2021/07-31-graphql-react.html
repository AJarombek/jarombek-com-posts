<div>
<p>
Last year, I started using <a href="https://jarombek.com/blog?query=graphql&page=1">GraphQL</a> at my job.  I decided to
create some GraphQL prototypes in my spare time, to get better acquainted with the GraphQL ecosystem.  In 2018 I learned
the basics of GraphQL and wrote <a href="https://jarombek.com/blog/aug-5-2018-graphql-pt1">two</a>
 <a href="https://jarombek.com/blog/aug-9-2018-graphql-pt2">articles</a> about my experience, but never dove into using
GraphQL in real world applications.  The <a href="https://github.com/AJarombek/graphql-react-prototype">GraphQL React prototype</a>
discussed in this article along with my <a href="https://github.com/AJarombek/apollo-client-server-prototype">Apollo prototype</a>
are the beginnings of that production application journey.  In the future, I plan on using GraphQL for the API layer of
my applications.
</p>
<p>
The GraphQL prototype discussed in this article is a <a href="https://jarombek.com/blog?query=react&page=1">React</a>
front-end application that connects to a GitHub GraphQL API.  The API provides details about my repositories, and React
displays those details in a dashboard.  The dashboard is shown below.
</p>
<figure>
<img className="jarombek-blog-image" src="https://asset.jarombek.com/posts/7-31-21-dashboard.png"/>
</figure>
<p>
The dashboard has a responsive design, so its also viewable on tablets and mobile screens.
</p>
<figure>
<img className="jarombek-blog-image" src="https://asset.jarombek.com/posts/7-31-21-dashboard-mobile.png"/>
</figure>
<SectionTitle title="GraphQL and React Application Code">GraphQL and React Application Code</SectionTitle>
<p>
The React code for the dashboard is broken down into multiple components, with each box displayed on the screen being
its own component.  Components use Less for their stylesheet language.  Less, similar to
<a href="https://jarombek.com/blog?query=sass&page=1">Sass</a>, is a CSS preprocessor, which adds features on top of
the base CSS language.
</p>
<p>
Each component makes a GraphQL query to the GitHub API, collecting the data it wishes to display.  The front-end code
doesn’t use a GraphQL client library to make the API calls, instead just using an HTTP client library called
<code className="jarombek-inline-code">axios</code>.  In an upcoming article I’ll discuss my
<a href="https://github.com/AJarombek/apollo-client-server-prototype">Apollo prototype</a>, which uses the Apollo Client
library to make API calls. While the HTTP client library is a more bare-bones approach, it is still fully capable of
handling GraphQL APIs.
</p>
<p>
Let’s look at one of the basic components displayed on the UI.  The <code className="jarombek-inline-code">RepositoryCount</code>
component has the responsibility of displaying the number of repositories in my GitHub account on the dashboard. It has
a <a href="https://github.com/AJarombek/graphql-react-prototype/blob/master/src/components/items/RepositoryCount.js">
RepositoryCount.js</a> file for the React component code and a <a href="https://github.com/AJarombek/
graphql-react-prototype/blob/master/src/components/items/RepositoryCount.less">RepositoryCount.less</a> file for the
stylesheet code.
</p>
<figure>
<img className="jarombek-blog-image" src="https://asset.jarombek.com/posts/7-31-21-repository-count-component.png"/>
</figure>
<p>
The <code className="jarombek-inline-code">RepositoryCount</code> component makes a GraphQL API call to the GitHub API
after the component first renders.  Once a result is returned from the API, the component re-renders with the number of
repositories in my GitHub account.
</p>
<CodeSnippet language="JavaScript">
import React, { useEffect, useState } from 'react';
import { getPersonalRepositories } from '../../datasource/GraphQL';

const RepositoryCount = () => {
  const [repoCount, setRepoCount] = useState(0);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function getGraphQLResult() {
      const result = await getPersonalRepositories('AJarombek');

      if (result.data.data) {
        setRepoCount(result.data.data.user.repositories.totalCount);
        setError(null);
      } else {
        setError(result.data.errors[0].message);
      }
    }

    getGraphQLResult();
  }, []);

  return (
    &lt;div className="items repository-count">
      {error
        ? (
          &lt;div className="error">
            &lt;h6>{error}&lt;/h6>
          &lt;/div>
        )
        : (
          <>
            &lt;h3>Number of Repositories&lt;/h3>
            &lt;h2>{repoCount}&lt;/h2>
          &lt;/>
        )}
    &lt;/div>
  );
};

export default RepositoryCount;
</CodeSnippet>
<p>
The repository count is held in a <code className="jarombek-inline-code">useState</code> React hook with the name
<code className="jarombek-inline-code">repoCount</code>. This value is changed using the
<code className="jarombek-inline-code">setRepoCount</code> function. When
<code className="jarombek-inline-code">setRepoCount</code> is invoked, the
<code className="jarombek-inline-code">RepositoryCount</code> component re-renders and displays the repository count in
an HTML <code className="jarombek-inline-code">&lt;h2&gt;</code> element. If an error occurs while making the API call,
the error message is stored in the <code className="jarombek-inline-code">error</code> variable, which is also managed
by a <code className="jarombek-inline-code">useState</code> React hook. If the <code className="jarombek-inline-code">error</code>
variable contains a string value, it is displayed in an HTML <code className="jarombek-inline-code">&lt;h6&gt;</code>
element.
</p>
<p>
The <code className="jarombek-inline-code">useEffect</code> React hook is invoked once after the component first
renders.  It’s purpose is to make the GitHub API call and store its response in a state variable.  The
<code className="jarombek-inline-code">getGraphQLResult()</code> function performs this task.  The first line of
<code className="jarombek-inline-code">getGraphQLResult()</code> calls a
<code className="jarombek-inline-code">getPersonalRepositories()</code> function, which is imported from another file. I
extracted all the API client logic into a separate file, which I will discuss later. The API call is asynchronous, which
is why I use the <code className="jarombek-inline-code">await</code> keyword.
<code className="jarombek-inline-code">getPersonalRepositories()</code> returns a JavaScript object with the API
response, and the remainder of the logic in <code className="jarombek-inline-code">getGraphQLResult()</code> handles the
response in the case of a success or failure.
</p>
<p>
If the API call is successful and the response object contains data, the repository count is assigned to the
<code className="jarombek-inline-code">repoCount</code> variable using the
<code className="jarombek-inline-code">setRepoCount</code> function. If the API call is unsuccessful and contains no
data, the API returns an error message.  This error message is assigned to the
<code className="jarombek-inline-code">error</code> variable using the <code className="jarombek-inline-code">setError</code>
function.
</p>
<SectionTitle title="Test Code and Infrastructure">Test Code and Infrastructure</SectionTitle>
<SectionTitle title="Conclusions">Conclusions</SectionTitle>
</div>
