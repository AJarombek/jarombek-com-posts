<div>
<Note type="info">
This is part of a series of articles on SaintsXCTF Version 2.0. The first article in the series provides an
<a href="https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview">overview of the application</a>.  You
<strong>DO NOT</strong> need to read prior articles in the series to fully understand this article.
</Note>
<p>
While researching API frameworks and libraries, I grew interested in the Flask framework.  Flask is very lightweight,
and allows engineers to quickly create APIs in Python without much opinionated tooling.  For example, Flask does not
come installed with a database access layer or ORM, allowing engineers to pick whichever database access library they
prefer.  This was appealing to me because I’d be able to configure and design the API to my liking.  Also, working in
Python allowed me to quickly write API code.
</p>
<p>
In this article, I begin by describing how I structured my SaintsXCTF API, which is written in Flask.  Next, I provide
an overview of Flask and SQLAlchemy, an object relational mapper (ORM).  Finally, I dive into my API code.  You can
view the code discussed in this article in my <a href="https://github.com/AJarombek/saints-xctf-api">saints-xctf-api</a>
repository.
</p>
<SubTitle title="SaintsXCTF Version 2.0 Articles">SaintsXCTF Version 2.0 Articles</SubTitle>
<ul>
<li><a href="https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview">Architectural Overview</a></li>
<li><a href="https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview">AWS Infrastructure</a></li>
<li><a href="https://jarombek.com/blog/oct-25-2021-saints-xctf-v2-k8s-infrastructure">Kubernetes Infrastructure</a></li>
<li><a href="https://jarombek.com/blog/nov-1-2021-saints-xctf-v2-react-web-app">React Web Application Overview</a></li>
<li><a href="https://jarombek.com/blog/nov-15-2021-react-typescript">Web Application React and TypeScript</a></li>
<li><a href="https://jarombek.com/blog/dec-3-2021-redux-react">Web Application Redux State Configuration</a></li>
<li><a href="https://jarombek.com/blog/aug-11-2021-cypress-typescript">Web Application Cypress E2E Tests</a></li>
<li><a href="https://jarombek.com/blog/jun-30-2021-react-jss">Web Application JSS Modular Design</a></li>b Application JSS Modular Design</li>
<li><strong>Flask Python API</strong></li>
<li>Flask API Testing</li>
<li>Flask API Docker & Docker Compose Configuration</li>
<li>Function API Using API Gateway & Lambda</li>
<li>Auth API Using API Gateway & Lambda</li>
<li>Database Deployments Using Jenkins</li>
<li>Database Client on Kubernetes</li>
<li>IOS Application Updates and Learning Experiences</li>
<li>Testing and Continuous Deployment on Jenkins</li>
<li>Post-Deployment Challenges & Future Improvements</li>
</ul>
<SectionTitle title="SaintsXCTF API Overview">SaintsXCTF API Overview</SectionTitle>
<p>
The SaintsXCTF API is a REST API that returns JSON structured data.  One of the main design principles I used for the
API is to include links in the JSON response bodies.  For example, take the entrypoint of the API.
</p>
<CodeSnippet language="Bash">
curl https://api.saintsxctf.com
</CodeSnippet>
<CodeSnippet language="JSON">
{
    "api_name":"saints-xctf-api",
    "self_link":"/",
    "versions_link":"/versions"
}
</CodeSnippet>
<p>
Two links are specified in the JSON response body.  The fields containing links are
<code className="jarombek-inline-code">self_link</code> and <code className="jarombek-inline-code">versions_link</code>.
<code className="jarombek-inline-code">self_link</code> specifies the current API endpoint, and
<code className="jarombek-inline-code">versions_link</code> specifies another endpoint that a user can navigate to.
This allows users with no knowledge of the API structure to navigate the API without needing to reference external
documentation.  Following the <strong>/versions</strong> endpoint specified in the
<code className="jarombek-inline-code">versions_link</code> field gives the following response.
</p>
<CodeSnippet language="Bash">
curl https://api.saintsxctf.com/versions
</CodeSnippet>
<CodeSnippet language="JSON">
{
   "self":"/versions",
   "version_1":null,
   "version_2":"/v2",
   "version_latest":"/v2"
}
</CodeSnippet>
<p>
Once again, this API response provides more links to follow.  I’m currently using the second version of my SaintsXCTF
API, so the remainder of my endpoints exist under the <strong>/v2</strong> route.
</p>
<CodeSnippet language="Bash">
curl https://api.saintsxctf.com/v2
</CodeSnippet>
<CodeSnippet language="JSON">
{
   "latest":true,
   "links":"/v2/links",
   "self":"/v2",
   "version":2
}
</CodeSnippet>
<p>
The root <strong>/v2</strong> route gives a bit of metadata about the API, and also provides a link to
<strong>/v2/links</strong>.  If a user follows this route, they receive a list of all the top-level application
endpoints in the API.
</p>
<CodeSnippet language="Bash">
curl https://api.saintsxctf.com/v2/links
</CodeSnippet>
<CodeSnippet language="JSON">
{
   "activation_code":"/v2/activation_code/links",
   "comment":"/v2/comments/links",
   "flair":"/v2/flair/links",
   "forgot_password":"/v2/forgot_password/links",
   "group":"/v2/groups/links",
   "log":"/v2/logs/links",
   "log_feed":"/v2/log_feed/links",
   "notification":"/v2/notifications/links",
   "range_view":"/v2/range_view/links",
   "self":"/v2/links",
   "team":"/v2/teams/links",
   "user":"/v2/users/links"
}
</CodeSnippet>
<p>
Let’s say you are navigating through the API and are interested in viewing user routes.  Following the
<strong>/v2/users/links</strong> route returns all the user endpoints that are available, and what each endpoint is
used for.
</p>
<CodeSnippet language="Bash">
curl https://api.saintsxctf.com/v2/users/links
</CodeSnippet>
<CodeSnippet language="JSON">
{
   "endpoints":[
      {
         "description":"Get all the users in the database.",
         "link":"/v2/users",
         "verb":"GET"
      },
      {
         "description":"Create a new user.",
         "link":"/v2/users",
         "verb":"POST"
      },
      {
         "description":"Retrieve a single user with a given username.",
         "link":"/v2/users/&lt;username>",
         "verb":"GET"
      },
      {
         "description":"Update a user with a given username.",
         "link":"/v2/users/&lt;username>",
         "verb":"PUT"
      },
      {
         "description":"Soft delete a user with a given username.",
         "link":"/v2/users/soft/&lt;username>",
         "verb":"DELETE"
      },
      ...
   ],
   "self":"/v2/users/links"
}
</CodeSnippet>
<p>
I shortened the API response for brevity.  After viewing this list of API endpoints, a user can determine which ones to
invoke to match their needs.  Let’s say you decide to invoke the GET endpoint <strong>/v2/users/&lt;username></strong>
with the username <strong>andy</strong>.  Doing so results in the following response:
</p>
<CodeSnippet language="Bash">
curl https://api.saintsxctf.com/v2/users/andy
</CodeSnippet>
<CodeSnippet language="JSON">
{
   "api_index":"/versions",
   "contact":"andrew@jarombek.com",
   "error_description":"Unauthorized",
   "exception":"401 Unauthorized: The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required."
}
</CodeSnippet>
<p>
Invoking the endpoint resulted in an HTTP 401 error.  Many of the endpoints in my API are protected, requiring a
temporary token in the <code className="jarombek-inline-code">Authorization</code> header in order to access the API.
If you don’t supply a token or provide an invalid token, the API returns 401 and 403 errors, respectively.  Providing
a valid token in the HTTP request header results in the response below.
</p>
<CodeSnippet language="Bash">
curl -H "Authorization: Bearer xxx" https://api.saintsxctf.com/v2/users/andy
</CodeSnippet>
<CodeSnippet language="JSON">
{
   "self":"/v2/users/andy",
   "user":{
      "activation_code":"BbXuat",
      "class_year":2017,
      "deleted":false,
      "description":"I sometimes like to run...",
      "email":"andrew@jarombek.com",
      "favorite_event":"Shakeout",
      "first":"Andy",
      "last":"Jarombek",
      "last_signin":"2021-05-30 18:42:42",
      "location":"New York, NY",
      "member_since":"2016-12-23",
      "password":"$2b$12$KDaX8hy3P1fZnG9nUVf1TeXw/rJJ4YaEXYdBi.Bx9k8v3DRFeHQ8a",
      "profilepic_name":"1629931871738.jpg",
      "salt":"RjJH6PIndLmr8S5sjgGUj8",
      "subscribed":null,
      "username":"andy",
      "week_start":"monday"
   }
}
</CodeSnippet>
<p>
I omitted the actual API token, a JWT, from the <code className="jarombek-inline-code">curl</code> command above.  This
time, the API responded successfully with a JSON object of my user in SaintsXCTF.
</p>
<p>
The SaintsXCTF API is a CRUD (<strong>C</strong>reate <strong>R</strong>ead <strong>U</strong>pdate
<strong>D</strong>elete) REST API.  Therefore, API endpoints aren’t limited to GET requests, but also POST, PUT, and
DELETE requests.  The example below is a POST request that creates a new exercise log for my user.
</p>
<CodeSnippet language="Bash">

RequestBody='{"username":"andy","first":"Andy","last":"Jarombek","name":"NYRR Night at the Races","location":"New York, NY","date":"2021-12-16","type":"run","distance":10.5,"metric":"miles","time":"00:00:00","feel":6,"description":""}'
curl -X POST \
    -d "${RequestBody}" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer xxx" \
    https://saintsxctf.com/api/v2/logs/
</CodeSnippet>
<CodeSnippet language="JSON">
{
   "added":true,
   "log":{
      "date":"2021-12-16",
      "deleted":false,
      "description":"",
      "distance":10.5,
      "feel":6,
      "first":"Andy",
      "last":"Jarombek",
      "location":"New York, NY",
      "log_id":47462,
      "metric":"miles",
      "miles":10.5,
      "name":"NYRR Night at the Races",
      "pace":"00:00:00",
      "time":"00:00:00",
      "time_created":"Fri, 17 Dec 2021 22:56:40 GMT",
      "type":"run",
      "username":"andy"
   },
   "self":"/v2/logs"
}
</CodeSnippet>
<p>
One of the main objectives of the API is to make it as easy to use and navigate as possible.  This not only improves
the experience for other users, but also for myself as I revisit and refactor the API codebase.  While adding links to
the JSON responses makes the API easier to explore, there is still some information that it lacks.  This includes
authentication mechanisms and documentation of JSON request body structures (such as for the exercise log creation
request shown above).  This information requires additional documentation.  I am currently working on Swagger API
documentation for this purpose, and will likely write about Swagger and the OpenAPI specification in a future article.
</p>
<SectionTitle title="Flask Overview">Flask Overview</SectionTitle>
<p>
Flask is a lightweight web application framework which is commonly used to build REST APIs.  Flask applications are
written in Python, with the <a href="https://pypi.org/project/Flask/">Flask library</a> at their core.  Flask doesn't
do much beyond handling routing, so a lot of the API functionality comes from other libraries (such as
<a href="https://pypi.org/project/Flask-SQLAlchemy/">flask-sqlalchemy</a> for a Database ORM,
<a href="https://pypi.org/project/Bcrypt-Flask/">flask-bcrypt</a> for bcrypt password hashing.
</p>
<SectionTitle title="SQLAlchemy Overview">SQLAlchemy Overview</SectionTitle>
<p>
In my API, SQLAlchemy is used for accessing a MySQL database.  I use the
<a href="https://pypi.org/project/Flask-SQLAlchemy/">flask-sqlalchemy</a> library, which is a wrapper around SQLAlchemy
that makes it easier to use in a Flask application.
</p>
<p>
SQLAlchemy is an ORM and SQL database library for Python.  SQLAlchemy works with many different database engines; in my
case, SQLAlchemy is used to query data from MySQL.
</p>
<SectionTitle title="API File Structure">API File Structure</SectionTitle>
<p>
In my <a href="https://github.com/AJarombek/saints-xctf-api">saints-xctf-api</a> repository, the Flask application
exists in an <a href="https://github.com/AJarombek/saints-xctf-api/tree/master/api/src">api/src</a> directory.
</p>
<InlineImage filename="12-24-21-api-file-structure.png">
</InlineImage>
<p>
The top level directory of the Flask application contains configuration files and infrastructure setup.  The
infrastructure setup consists of an Nginx reverse-proxy server (<a href="https://github.com/AJarombek/saints-xctf-api/
blob/master/api/src/nginx.conf">nginx.conf</a>), a uWSGI application server (<a href="https://github.com/AJarombek/
saints-xctf-api/blob/master/api/src/uwsgi.ini">uwsgi.ini</a>), and Dockerfiles for each.  The configuration files for
Flask are discussed in the next section.
</p>
<p>
<strong>dao</strong> contains files that follow the Data Access Object (DAO) pattern<sup>1</sup>.  In essence, each DAO
file consists of a class with methods which interact with the MySQL database using SQLAlchemy.  <strong>model</strong>
contains models for use in the SQLAlchemy ORM.  Each model is a Python class that corresponds to a table in MySQL.
<strong>route</strong> defines all the routes (endpoints) in the API.  Each route is bound to a Python function which
performs the logic needed to return a proper HTTP response.  <strong>test</strong> contains unit and integration tests
for the API.  <strong>utils</strong> contains reusable utility functions used throughout the API.
</p>
<SectionTitle title="Flask Configuration">Flask Configuration</SectionTitle>
<p>
The configuration of my Flask application begins with a small file named
<a href="https://github.com/AJarombek/saints-xctf-api/blob/master/api/src/main.py">main.py</a>.
</p>
<CodeSnippet language="Python">
# main.py

from app import app
</CodeSnippet>
<p>
<strong>main.py</strong> is the entrypoint for the Flask application in the production environment.  A uWSGI
application server uses this file to run the API.  <strong>main.py</strong> simply imports a variable named
<code className="jarombek-inline-code">app</code> from <a href="https://github.com/AJarombek/saints-xctf-api/blob/
master/api/src/app.py">app.py</a>.  <code className="jarombek-inline-code">app</code> is an instance of
<code className="jarombek-inline-code">Flask</code>, an object representing the Flask application.  I initialize
<code className="jarombek-inline-code">app</code> in a <code className="jarombek-inline-code">create_app()</code>
function, found within <a href="https://github.com/AJarombek/saints-xctf-api/blob/master/api/src/app.py#L32-L149">
app.py</a>.
</p>
<CodeSnippet language="Python">
# app.py

def create_app(config_name) -> Flask:
    """
    Application factory function for the Flask app.
    Source: http://flask.pocoo.org/docs/1.0/patterns/appfactories/
    """
    application = Flask(__name__)
    application.config.from_object(config[config_name])

    application.register_blueprint(activation_code_route)
    application.register_blueprint(api_route)
    application.register_blueprint(user_route)
    application.register_blueprint(forgot_password_route)
    application.register_blueprint(flair_route)
    application.register_blueprint(log_route)
    application.register_blueprint(log_feed_route)
    application.register_blueprint(group_route)
    application.register_blueprint(comment_route)
    application.register_blueprint(range_view_route)
    application.register_blueprint(notification_route)
    application.register_blueprint(team_route)

    application.config['SQLALCHEMY_DATABASE_URI'] = get_connection_url()
    application.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    application.config['SQLALCHEMY_RECORD_QUERIES'] = True
    application.config['SLOW_DB_QUERY_TIME'] = 0.5

    db.init_app(application)
    flask_bcrypt.init_app(application)

    application.cli.add_command(test)

    # Custom Error Handling
    @application.errorhandler(401)
    def error_403(ex):
        """
        Custom error handler for when 401 HTTP codes occur.
        :param ex: String representing the error that occurred.
        :return: JSON describing the error.
        """
        return jsonify({
            'error_description': "Unauthorized",
            'exception': str(ex),
            'contact': 'andrew@jarombek.com',
            'api_index': '/versions'
        }), 401

    ...

    return application


flask_env = os.getenv('FLASK_ENV') or 'local'
app = create_app(flask_env)
</CodeSnippet>
<p>
I simplified <code className="jarombek-inline-code">create_app()</code> a bit, making it easier to discuss.
<code className="jarombek-inline-code">create_app()</code> takes a single <code className="jarombek-inline-code">
config_name</code> argument, which is the environment that the Flask application is run within.  For example, when run
in production, the value of <code className="jarombek-inline-code">config_name</code> is <strong>production</strong>.
The first line, <code className="jarombek-inline-code">application = Flask(__name__)</code>, creates an instance of
<code className="jarombek-inline-code">Flask</code>.  <code className="jarombek-inline-code">application</code> is
eventually the return value of <code className="jarombek-inline-code">create_app()</code>, and represents the Flask API.
</p>
<p>
The next line, <code className="jarombek-inline-code">application.config.from_object(config[config_name])</code>, sets
configuration key-value pairs for the Flask application.  The values of the configuration are environment specific.
<code className="jarombek-inline-code">config[config_name]</code> is a Python object with properties.
<code className="jarombek-inline-code">config</code> is defined in a <a href="https://github.com/AJarombek/
saints-xctf-api/blob/master/api/src/config.py">config.py</a> file, as shown below.
</p>
<CodeSnippet language="Python">
# config.py

class LocalConfig:
    ENV = 'local'
    AUTH_URL = 'http://saints-xctf-auth:5000'
    FUNCTION_URL = 'https://dev.fn.saintsxctf.com'


class DevelopmentConfig:
    ENV = 'dev'
    AUTH_URL = 'https://dev.auth.saintsxctf.com'
    FUNCTION_URL = 'https://dev.fn.saintsxctf.com'


class ProductionConfig:
    ENV = 'prod'
    AUTH_URL = 'https://auth.saintsxctf.com'
    FUNCTION_URL = 'https://fn.saintsxctf.com'


config = {
    'local': LocalConfig,
    'development': DevelopmentConfig,
    'production': ProductionConfig
}
</CodeSnippet>
<SectionTitle title="Database Models">Database Models</SectionTitle>
<SectionTitle title="Data Access Objects">Data Access Objects</SectionTitle>
<SectionTitle title="API Routes">API Routes</SectionTitle>
<SectionTitle title="Route Decorators">Route Decorators</SectionTitle>
<SectionTitle title="Conclusions">Conclusions</SectionTitle>
</div>