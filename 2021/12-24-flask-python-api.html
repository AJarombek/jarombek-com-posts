<div>
<Note type="info">
This is part of a series of articles on SaintsXCTF Version 2.0. The first article in the series provides an
<a href="https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview">overview of the application</a>.  You
<strong>DO NOT</strong> need to read prior articles in the series to fully understand this article.
</Note>
<p>
While researching API frameworks and libraries, I grew interested in the Flask framework.  Flask is very lightweight,
and allows engineers to quickly create APIs in Python without much opinionated tooling.  For example, Flask does not
come installed with a database access layer or ORM, allowing engineers to pick whichever database access library they
prefer.  This was appealing to me because I’d be able to configure and design the API to my liking.  Also, working in
Python allowed me to quickly write API code.
</p>
<p>
In this article, I begin by describing how I structured my SaintsXCTF API, which is written in Flask.  Next, I provide
an overview of Flask and SQLAlchemy, an object relational mapper (ORM).  Finally, I dive into my API code.  You can
view the code discussed in this article in my <a href="https://github.com/AJarombek/saints-xctf-api">saints-xctf-api</a>
repository.
</p>
<SubTitle title="SaintsXCTF Version 2.0 Articles">SaintsXCTF Version 2.0 Articles</SubTitle>
<ul>
<li><a href="https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview">Architectural Overview</a></li>
<li><a href="https://jarombek.com/blog/jun-14-2021-saints-xctf-v2-overview">AWS Infrastructure</a></li>
<li><a href="https://jarombek.com/blog/oct-25-2021-saints-xctf-v2-k8s-infrastructure">Kubernetes Infrastructure</a></li>
<li><a href="https://jarombek.com/blog/nov-1-2021-saints-xctf-v2-react-web-app">React Web Application Overview</a></li>
<li><a href="https://jarombek.com/blog/nov-15-2021-react-typescript">Web Application React and TypeScript</a></li>
<li><a href="https://jarombek.com/blog/dec-3-2021-redux-react">Web Application Redux State Configuration</a></li>
<li><a href="https://jarombek.com/blog/aug-11-2021-cypress-typescript">Web Application Cypress E2E Tests</a></li>
<li><a href="https://jarombek.com/blog/jun-30-2021-react-jss">Web Application JSS Modular Design</a></li>b Application JSS Modular Design</li>
<li><strong>Flask Python API</strong></li>
<li>Flask API Testing</li>
<li>Flask API Docker & Docker Compose Configuration</li>
<li>Function API Using API Gateway & Lambda</li>
<li>Auth API Using API Gateway & Lambda</li>
<li>Database Deployments Using Jenkins</li>
<li>Database Client on Kubernetes</li>
<li>IOS Application Updates and Learning Experiences</li>
<li>Testing and Continuous Deployment on Jenkins</li>
<li>Post-Deployment Challenges & Future Improvements</li>
</ul>
<SectionTitle title="SaintsXCTF API Overview">SaintsXCTF API Overview</SectionTitle>
<p>
The SaintsXCTF API is a REST API that returns JSON structured data.  One of the main design principles I used for the
API is to include links in the JSON response bodies.  For example, take the entrypoint of the API.
</p>
<CodeSnippet language="Bash">
curl https://api.saintsxctf.com
</CodeSnippet>
<CodeSnippet language="JSON">
{
    "api_name":"saints-xctf-api",
    "self_link":"/",
    "versions_link":"/versions"
}
</CodeSnippet>
<p>
Two links are specified in the JSON response body.  The fields containing links are
<code className="jarombek-inline-code">self_link</code> and <code className="jarombek-inline-code">versions_link</code>.
<code className="jarombek-inline-code">self_link</code> specifies the current API endpoint, and
<code className="jarombek-inline-code">versions_link</code> specifies another endpoint that a user can navigate to.
This allows users with no knowledge of the API structure to navigate the API without needing to reference external
documentation.  Following the <strong>/versions</strong> endpoint specified in the
<code className="jarombek-inline-code">versions_link</code> field gives the following response.
</p>
<CodeSnippet language="Bash">
curl https://api.saintsxctf.com/versions
</CodeSnippet>
<CodeSnippet language="JSON">
{
   "self":"/versions",
   "version_1":null,
   "version_2":"/v2",
   "version_latest":"/v2"
}
</CodeSnippet>
<p>
Once again, this API response provides more links to follow.  I’m currently using the second version of my SaintsXCTF
API, so the remainder of my endpoints exist under the <strong>/v2</strong> route.
</p>
<CodeSnippet language="Bash">
curl https://api.saintsxctf.com/v2
</CodeSnippet>
<CodeSnippet language="JSON">
{
   "latest":true,
   "links":"/v2/links",
   "self":"/v2",
   "version":2
}
</CodeSnippet>
<p>
The root <strong>/v2</strong> route gives a bit of metadata about the API, and also provides a link to
<strong>/v2/links</strong>.  If a user follows this route, they receive a list of all the top-level application
endpoints in the API.
</p>
<CodeSnippet language="Bash">
curl https://api.saintsxctf.com/v2
</CodeSnippet>
<CodeSnippet language="JSON">
{
   "activation_code":"/v2/activation_code/links",
   "comment":"/v2/comments/links",
   "flair":"/v2/flair/links",
   "forgot_password":"/v2/forgot_password/links",
   "group":"/v2/groups/links",
   "log":"/v2/logs/links",
   "log_feed":"/v2/log_feed/links",
   "notification":"/v2/notifications/links",
   "range_view":"/v2/range_view/links",
   "self":"/v2/links",
   "team":"/v2/teams/links",
   "user":"/v2/users/links"
}
</CodeSnippet>
<SectionTitle title="Flask Overview">Flask Overview</SectionTitle>
<SectionTitle title="SQLAlchemy Overview">SQLAlchemy Overview</SectionTitle>
<SectionTitle title="API File Structure">API File Structure</SectionTitle>
<SectionTitle title="Flask Configuration">Flask Configuration</SectionTitle>
<SectionTitle title="Database Models">Database Models</SectionTitle>
<SectionTitle title="Data Access Objects">Data Access Objects</SectionTitle>
<SectionTitle title="API Routes">API Routes</SectionTitle>
<SectionTitle title="Route Decorators">Route Decorators</SectionTitle>
<SectionTitle title="Conclusions">Conclusions</SectionTitle>
</div>