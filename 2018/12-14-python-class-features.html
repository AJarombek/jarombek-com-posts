<div>
<p>
In this discovery post, I’m exploring some of the interesting features of Python classes.  Python
fully supports the object oriented paradigm, and I explored certain features that assist writing
object oriented code such as the <a href="https://jarombek.com/blog/sep-24-2018-python-data-model">
data model</a> in past articles.  Learning all the different object oriented features of a language
assists in creating effective APIs.  Hopefully this knowledge will help assist my Python object
creation in the future.
</p>
<SectionTitle title="Investigating Python Methods">Investigating Python Methods</SectionTitle>
<p>
I created a class named <code class="jarombek-inline-code">Meta</code> to help explore different
object oriented features.  It holds two pieces of information, the first and last name of whoever
created an object instance.  Here is the class outline:
</p>
<CodeSnippet language="Python">
class Meta:

  def __init__(self, first_name: str, last_name: str) -> None:
    """
    Construct a new Meta object which contains the first and last name of its creator
    :param first_name: the first name of the objects creator
    :param last_name: the last name of the objects creator
    """
    self.__first_name = first_name
    self.__last_name = last_name

  ...
</CodeSnippet>
<p>
One thing you may notice about this Python code is that I’m using type hints for the argument types
and method return types.  Type hints in Python aren’t strictly enforced, but they help IDE’s identify
code that doesn’t follow expected types<sup>1</sup>.  They were first introduced in Python 3.5 in
2015.  The type hints in the <code class="jarombek-inline-code">Meta</code> class tell us that
<code class="jarombek-inline-code">first_name</code> and <code class="jarombek-inline-code">
last_name</code> are expected to be of type <code class="jarombek-inline-code">str</code> and that
the special <code class="jarombek-inline-code">__init__()</code> function returns
<code class="jarombek-inline-code">None</code>.  Perhaps I’ll write a full article about type hints
in the future!
</p>
<p>
When writing Python classes, one way to create specialized methods is decorators (annotations).
Decorators wrap methods with additional functionality.  One of the basic decorators is
<code class="jarombek-inline-code">@property</code>, which creates a getter method.  In
<code class="jarombek-inline-code">Meta</code> I created getter methods for the internal
<code class="jarombek-inline-code">__first_name</code> and <code class="jarombek-inline-code">
__last_name</code> properties.
</p>
<CodeSnippet language="Python">
@property
def first_name(self) -> str:
  """
  @property marks this function as a getter method.  This method gets the internal
  first_name property of Meta.
  :return: A string representing the owners first name
  """
  return self.__first_name

@property
def last_name(self) -> str:
  """
  This method gets the internal last_name property of Meta.
  :return: A string representing the owners last name
  """
  return self.__last_name
</CodeSnippet>
<p>
Now that these getter methods are created, the internal <code class="jarombek-inline-code">
__first_name</code> and <code class="jarombek-inline-code">__last_name</code> properties are accessible
through the <code class="jarombek-inline-code">first_name</code> and <code class="jarombek-inline-code">
last_name</code>.  If you try accessing the <code class="jarombek-inline-code">__first_name</code>
or <code class="jarombek-inline-code">__last_name</code> properties an <code class="jarombek-inline-code">
AttributeError</code> is thrown.
</p>
<CodeSnippet language="Python">
meta = Meta("Andy", "J")
assert meta.first_name == "Andy"
assert meta.last_name == "J"

try:
  assert meta.__first_name == "Andy"
except AttributeError:
  print('Unable to find property __first_name in class Meta')
</CodeSnippet>
<CodeSnippet>
Unable to find property __first_name in class Meta
</CodeSnippet>
<p>
Classes also typically have special methods defined in Python’s data model.  The
<code class="jarombek-inline-code">Meta</code> class contains the <code class="jarombek-inline-code">
__format__()</code> special method which is invoked from the <code class="jarombek-inline-code">
format()</code> built-in method.  <code class="jarombek-inline-code">format()</code> returns a string
representation of an object.
</p>
<CodeSnippet language="Python">
def __format__(self, format_spec: str=''):
  """
  Special method to format a string representation of the Meta object
  :param format_spec: the formatting specifier
  :return: a formatted string representing the instance
  """
  components = (format(self.__dict__[prop], format_spec) for prop in self.__dict__)
  return '({}, {})'.format(*components)
</CodeSnippet>
<CodeSnippet>
meta = Meta("Andrew", "Jarombek")
assert format(meta, '') == '(Andrew, Jarombek)'
</CodeSnippet>
<p>
<code class="jarombek-inline-code">__format__()</code> is interesting because it uses the objects
internal dictionary <code class="jarombek-inline-code">__dict__</code>.  Each object instance has
a <code class="jarombek-inline-code">__dict__</code> property which contains all the objects instance
attributes.  For <code class="jarombek-inline-code">Meta</code> these instance attributes are the
first and last name.  In <code class="jarombek-inline-code">__format__()</code>, the variable
<code class="jarombek-inline-code">components</code> is assigned to a generator which loops through
each item in <code class="jarombek-inline-code">__dict__</code> and formats them.  Finally
<code class="jarombek-inline-code">components</code> is passed to a strings
<code class="jarombek-inline-code">format()</code> method and returned.
</p>
<p>
You may be expecting <code class="jarombek-inline-code">__dict__</code> to contain both
<code class="jarombek-inline-code">__first_name</code> and <code class="jarombek-inline-code">__last_name
</code>.  While this would make sense, Python actually name mangles any attributes that begin with two
underscores<sup>2</sup>.  Python adds the class name into the instance attribute, so
<code class="jarombek-inline-code">__first_name</code> becomes <code class="jarombek-inline-code">
_Meta__first_name</code>.
</p>
<CodeSnippet language="Python">
meta = Meta("Andrew", "Jarombek")

assert meta.__dict__ == {'_Meta__first_name': 'Andrew', '_Meta__last_name': 'Jarombek'}
assert meta.__dict__['_Meta__first_name'] == 'Andrew'
assert meta.__dict__['_Meta__last_name'] == 'Jarombek'
</CodeSnippet>
<p>
Using the per instance <code class="jarombek-inline-code">__dict__</code> demonstrates a common
approach in many programming languages - safety over security.  Although instance attributes
beginning with double underscores are considered private attributes and are name mangled, they are
still accessible through the <code class="jarombek-inline-code">__dict__</code> property (and
through default attribute access).  In a similar sense, private instance variables in Java are only
about safety, since they can still be accessed through <a href="https://jarombek.com/blog/
jul-1-2018-java-reflection">reflection</a>.  Safety is about protecting developers from common
mistakes and maintaining elegant code, not stopping them from performing certain actions.
</p>
<p>
Methods in Python are given a special first argument commonly named <code class="jarombek-inline-code">
self</code>.  This name is not strictly enforced by Python, but it's convention and considered a best
practice.  <code class="jarombek-inline-code">self</code> refers to the object itself, and can be
used like any other object reference.
</p>
<p>
With the help of decorators, we can change the special first argument passed to methods.  There are
two decorators up to the task, <code class="jarombek-inline-code">@classmethod</code> and
<code class="jarombek-inline-code">@staticmethod</code>.  <code>@classmethod</code> changes the first
argument from the object instance to the class itself<sup>3</sup>.  <code class="jarombek-inline-code">
@staticmethod</code> completely removes the first special argument.
</p>
<p>
<code class="jarombek-inline-code">@classmethod</code> is commonly used for alternative constructors
(known as <a href="https://jarombek.com/blog/may-20-2018-java-generics-api">static factory methods</a>
in Java).  I also created a class method that returns basic information about the class.
</p>
<CodeSnippet language="Python">
@classmethod
def about(cls) -> None:
  """
  @classmethod alters this method to belong to the class instead of an object instance.
  Therefore the first argument to this method is the class itself instead of the object
  instance.  This method prints out some important properties of the class.
  :return: None
  """
  print('Class Name: {}'.format(cls.__name__))
  print('Class Dict: {}'.format(cls.__dict__))

@classmethod
def create(cls):
  """
  Alternative constructor using a class method.  In Java, this construct is known as a
  'static factory method'
  :return: An instance of Meta
  """
  return cls("Andrew", "Jarombek")
</CodeSnippet>
<CodeSnippet language="Python">
# Construct using the class method
meta = Meta.create()

assert meta.first_name == "Andrew"
assert meta.last_name == "Jarombek"
</CodeSnippet>
<p>
<code class="jarombek-inline-code">@staticmethod</code> does not have many uses, however you can
use it to logically group a function into a class.  I created a static method which simply calls
<code class="jarombek-inline-code">Meta.create()</code>.
</p>
<CodeSnippet language="Python">
@staticmethod
def static_create():
  """
  Alternative constructor using a static method.  Static methods receive no special
  first method unlike class methods and plain methods.
  :return: An instance of Meta
  """
  return Meta.create()
</CodeSnippet>
<SectionTitle title="Altering an Object’s Internal Storage Mechanism">Altering an Object’s Internal Storage Mechanism</SectionTitle>
<p>
I already went over how each object instance contains metadata in the <code class="jarombek-inline-code">
__dict__</code> property.  While this approach works well most of the time, it can get expensive for
each object instance to store an internal dictionary data structure<sup>4</sup>.
</p>
<p>
If you have millions of object instances derived from the same class, its less expensive to maintain
a per-instance tuple rather than a per-instance dictionary.  Python provides this alternative metadata
storage mechanism with the <code class="jarombek-inline-code">__slots__</code> property.  The
<code class="jarombek-inline-code">__slots__</code> tuple maintains all the instance attributes of a class.
</p>
<CodeSnippet language="Python">
class CodeWritten:

  # The __slots__ tuple replaces the per-instance __dict__
  __slots__ = ('__day', '__language', '__amount')

  def __init__(self, day: date, language: str, amount: int) -> None:
    """
    Construct a new CodeWritten instance which represents the number of lines coded
    in a specific language on a certain day
    :param day: The day the code was written
    :param language: The language the code was written in
    :param amount: The number of lines coded
    """
    self.__day = day
    self.__language = language
    self.__amount = amount

  @property
  def day(self) -> date:
    return self.__day

  @property
  def language(self) -> str:
    return self.__language

  @property
  def amount(self) -> int:
    return self.__amount


  if __name__ == '__main__':
    python_today = CodeWritten(date.today(), 'Python', 146)
    groovy_today = CodeWritten(date.today(), 'Groovy', 50)
    yaml_today = CodeWritten(date.today(), 'YAML', 12)

    assert python_today.amount == 146
    assert python_today.language == 'Python'
    assert python_today.day == date.today()

    # Using __slots__ removes the ability to add new instance attributes
    try:
      python_today.minutes_spent_working = 60
    except AttributeError:
      print('Unable to add an attribute not declared in __slots__')
</CodeSnippet>
<CodeSnippet>
Unable to add an attribute not declared in __slots__
</CodeSnippet>
<p>
A side effect of using <code class="jarombek-inline-code">__slots__</code> is that no other instance
attributes are allowed in an object other than the ones defined in <code class="jarombek-inline-code">
__slots__</code>.  While <code class="jarombek-inline-code">__slots__</code> can be used as a way
to prevent users from adding attributes to objects, this is considered a bad practice in the Python
community<sup>5</sup>.  Preventing users from adding attributes is not what <code class="jarombek-inline-code">
__slots__</code> was designed for.
</p>
<SectionTitle title="Conclusions">Conclusions</SectionTitle>
<p>
This post continues my journey through Python and its advanced features.  My <a href="https://jarombek.com/blog/dec-15-2018-python-protocols-abcs">next post</a>
will look at Python protocols and ABCs.
</p>
</div>