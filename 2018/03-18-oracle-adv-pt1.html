<div>
<p>
In this installment of my Oracle discoveries, I dig into analytic functions and some other
advanced queries.  In the <a href="https://jarombek.com/blog/feb-12-2018-oracle-start">first</a> Oracle discovery
I created a new database and set up basic tables. In the <a href="https://jarombek.com/blog/mar-2-2018-oracle-queries">
second</a> discovery I wrote intermediate level queries for the database.  I continue building
my Oracle knowledge in this discovery post!
</p>
<p>
The database I built contains books and programming languages.
There is a relationship between books and languages, since all the books are about programming!
</p>
<p>
The first query that uses analytic functions ranks programming languages by the
time spent reading about them.  There are two main functions used for ranking -
<code className="jarombek-inline-code">RANK()</code> and <code className="jarombek-inline-code">
DENSE_RANK()</code>.  The only difference between them is the way they handle ties in the
rankings<sup>1</sup>.  The difference in rankings is apparent in the following query:
</p>
<CodeSnippet language="SQL">
SELECT
    l.name,
    SUM(b.time_reading),
    RANK() OVER (ORDER BY SUM(b.time_reading) DESC NULLS LAST) AS rank,
    DENSE_RANK() OVER (ORDER BY SUM(b.time_reading) DESC NULLS LAST) AS dense_rank
FROM books b
INNER JOIN book_languages l ON b.isbn = l.isbn
GROUP BY l.name
ORDER BY rank;
</CodeSnippet>
<span className="code-span">
NAME         SUM(B.TIME_READING) RANK      DENSE_RANK
------------ ------------------- --------- ---------------
Java         134                 1         1
PL/SQL       26                  2         2
SQL          26                  2         2
JavaScript                       4         3
</span>
<p>
An interesting piece of this query is the <code className="jarombek-inline-code">NULLS LAST</code>
clause.  When ordering items, <code className="jarombek-inline-code">null</code> values come
first by default.  In this query <code className="jarombek-inline-code">null</code> is equivalent to zero time reading, so I want them to come
last.  The <code className="jarombek-inline-code">NULLS LAST</code> clause performs this switch.
</p>
<p>
Ranks can also be partitioned into subgroups by specifying a <code className="jarombek-inline-code">PARTITION BY</code> column.
Partitions are a bit too complex for my basic <code className="jarombek-inline-code">book_languages</code>
table, so I created a new table <code className="jarombek-inline-code">code_written</code> that is used for
the remaining examples.  This table contains a year, language, and lines
of code written in that language for the year (these are real statistics!):
</p>
<CodeSnippet language="SQL">
CREATE TABLE code_written(
    written_id INTEGER GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1 INCREMENT BY 1
    ),
    year INTEGER NOT NULL,
    language VARCHAR2(63) NOT NULL,
    lines INTEGER NOT NULL,
    CONSTRAINT code_written_language_fk
        FOREIGN KEY (language) REFERENCES languages(name) ON DELETE CASCADE
);
</CodeSnippet>
<p>
With this new table I can partition rankings based on the year, creating a new yearly ranking!
</p>
<CodeSnippet language="SQL">
SELECT
    year,
    language,
    lines,
    RANK() OVER (PARTITION BY year ORDER BY lines DESC) AS yearly_rank,
    RANK() OVER (ORDER BY lines DESC) AS all_time_rank
FROM code_written
ORDER BY year, yearly_rank;
</CodeSnippet>
<span className="code-span">
YEAR    LANGUAGE       LINES           YEARLY_RANK     ALL_TIME_RANK
------- -------------- --------------- --------------- ---------------
2014	Java           4282            1               7
2015	Java           1585            1               14
2015	Python         931             2               23
2015	C              630             3               27
2015	XML            42              4               40
2015	JSON           32              5               42
2016	Java           12962           1               1
2016	PHP            5433            2               6
2016	XML            2646            3               9
2016	JavaScript     2008            4               10
2016	HTML           1413            5               15
....    ....           ....            .               ..
</span>
<p>
Other types of rankings are available such as percentile rankings.  With a percentile ranking I see that Java in 2015
was in the top 30% of performances all time.
</p>
<CodeSnippet language="SQL">
SELECT
  year,
  language,
  lines,
  ROUND(PERCENT_RANK() OVER (PARTITION BY year ORDER BY lines DESC), 2) AS yearly_distribution,
  ROUND(PERCENT_RANK() OVER (ORDER BY lines DESC), 2) AS all_time_distribution
FROM code_written
ORDER BY year, yearly_distribution;
</CodeSnippet>
<span className="code-span">
YEAR     LANGUAGE     LINES           YEARLY_DISTRIBUTION ALL_TIME_DISTRIBUTION
-------- ------------ --------------- ------------------- ---------------------
2014	 Java         4282            0                   0.14
2015	 Java         1585            0                   0.3
2015     Python       931             0.25                0.5
2015     C            630             0.5                 0.59
2015     XML          42              0.75                0.89
2015     JSON         32              1                   0.93
2016     Java         12962           0                   0
2016     PHP          5433            0.1                 0.11
2016     XML          2646            0.2                 0.18
2016     JavaScript   2008            0.3                 0.2
2016     HTML         1413            0.4                 0.32
....     ....         ....            ...                 ....
</span>
<p>
The following query tries to find the median value for each language.  The implementation of this function
goes a bit over my head<sup>2</sup>!
</p>
<CodeSnippet language="SQL">
SELECT
    language,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY lines DESC) AS median
FROM code_written GROUP BY language;
</CodeSnippet>
<span className="code-span">
LANGUAGE              MEDIAN
--------------------- ----------
C                     325
CSS                   1233
HTML                  1413
JSON                  466
Java                  4282
JavaScript            2008
PHP                   3670
PL/SQL                203
Python                1026.5
SQL                   812
Sass                  303
Swift                 5414.5
TypeScript            991.5
XML                   1344
</span>
<p>
The next couple queries all utilize window functions.  Window functions apply an aggregate function
such as <code className="jarombek-inline-code">AVG()</code> or
<code className="jarombek-inline-code">SUM()</code> to a subset of rows in a result set<sup>3</sup>.
This subset is known as the window.  Here's an example of a
window function query that shows the cumulative sum of lines written:
</p>
<CodeSnippet language="SQL">
SELECT
    year,
    SUM(lines) AS total_lines,
    SUM(SUM(lines)) OVER (ORDER BY year ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
        as cumulative_lines
FROM code_written
GROUP BY year;
</CodeSnippet>
<span className="code-span">
YEAR     TOTAL_LINES CUMULATIVE_LINES
----- -------------- ----------------
2014            4282             4282
2015            3220             7502
2016           29161            36663
2017           47140            83803
2018            5986            89789
</span>
<p>
The column aliased as <code className="jarombek-inline-code">cumulative_lines</code> is really
interesting.  Its SQL statement starts by saying "compute the sum of all the
rows in the window with the statement <code className="jarombek-inline-code">SUM(SUM(lines))</code>".  Next I
defined what rows are in the window.  <code className="jarombek-inline-code">ORDER BY year</code>
accumulates the sum in a yearly order.  This is enforced with <code className="jarombek-inline-code">
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>, which says the window consists of this row and all rows prior.
</p>
<p>
Other cool data analysis operations are possible with window functions such as moving averages and
centered averages.  I show both of these examples below.  Look closely at how the window is defined
in each query.
</p>
<CodeSnippet language="SQL">
-- Perform a moving average by specifying that the current row and two preceding rows
-- will be included in the window calculation of AVG()
SELECT
    year,
    SUM(lines) AS total_lines,
    AVG(SUM(lines)) OVER (ORDER BY year ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)
        as cumulative_lines
FROM code_written
GROUP BY year;

-- Perform a centered average by specifying that the window consists of the current row,
-- the previous row, and the next row.
SELECT
    year,
    SUM(lines) AS total_lines,
    AVG(SUM(lines)) OVER (ORDER BY year ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
        as cumulative_lines
FROM code_written
GROUP BY year;
</CodeSnippet>
<p>
If you want to get a certain value in a window, use <code className="jarombek-inline-code">
FIRST_VALUE()</code> to get the first row in the
window, <code className="jarombek-inline-code">LAST_VALUE()</code> to get the last row, or
<code className="jarombek-inline-code">NTH_VALUE()</code> to get any other row.  When the first value in the
window is predictable beforehand you can do really powerful things.  For example,
in the following query I know that <code className="jarombek-inline-code">FIRST_VALUE()</code> returns
the previous years total lines written.   I can easily to perform comparisons between the row in the
query and the first row in the window, such as the percentage change between the two:
</p>
<CodeSnippet language="SQL">
SELECT
    year,
    SUM(lines) AS total_lines,
    FIRST_VALUE(SUM(lines))
        OVER (ORDER BY year ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS last_year_total,
    ROUND(SUM(lines) / FIRST_VALUE(SUM(lines))
        OVER (ORDER BY year ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) * 100, 2)
        || '%' AS percent_change
FROM code_written
GROUP BY year;
</CodeSnippet>
<span className="code-span">
YEAR       TOTAL_LINES LAST_YEAR_TOTAL PERCENT_CHANGE
------ --------------- --------------- ---------------
  2014            4282            4282 100%
  2015            3220            4282 75.2%
  2016           29161            3220 905.62%
  2017           47140           29161 161.65%
  2018            5986           47140 12.7%
</span>
<p>
The final query in this discovery lists all the languages used each year ordered from
most used to least used.  You can combine column values across multiple rows with the
<code className="jarombek-inline-code">LISTAGG()</code> function along with the
<code className="jarombek-inline-code">WITHIN GROUP</code> clause.
</p>
<CodeSnippet language="SQL">
SELECT
    year,
    LISTAGG(language, ', ') WITHIN GROUP (ORDER BY year, lines desc) AS languages_used,
    SUM(lines) as total_lines
FROM code_written
GROUP BY year;
</CodeSnippet>
<span className="code-span">
YEAR  LANGUAGES_USED                                TOTAL_LINES
----- --------------------------------------------- ------------
2014  Java                                          4282
2015  Java, Python, C, XML, JSON                    3220
2016  Java, PHP, XML, JavaScript, HTML, ...         29161
2017  Java, Swift, JavaScript, XML, PHP, ...        47140
2018  TypeScript, JavaScript, Java, SQL, ...        5986
</span>
<p>
In my next <a href="https://jarombek.com/blog/mar-19-2018-oracle-adv-pt2">discovery</a> I will look at the <code className="jarombek-inline-code">MODEL</code> clause and the incredibly
cool <code className="jarombek-inline-code">PIVOT</code> clause that pivots a table on a certain column!
</p>
</div>