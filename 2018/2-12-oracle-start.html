<div>
<p>
I recently finished looking at Java 8 (which was the topic of recent discoveries) and now am doing a deep
dive into the Oracle database.  Although I don't use Oracle a ton in my free time I use it a lot at work
and it is the <a href="http://pypl.github.io/DB.html">most popular database</a> at the moment.  Therefore
it is good to know well!
</p>
<p>
This discovery is going to follow me through the setup of my database.  I will skip the actually Oracle
installation and configuration (which was a challenge itself!) and skip straight to the moment I started
typing SQL.
</p>
<p>
A disclaimer before I begin.  A lot of my discoveries are about languages and technologies that I really
love using.  In this case I wouldn't say that I love Oracle but it is a good tool to have in the kit.
Just try installing an Oracle product and you will begin to see why many get frustrated with this
database!  One bright spot would be the PL/SQL language, which allows developers to add some
really cool functionality at the database layer of applications.  I won't be going into PL/SQL much
this time around but definitely will in the future!
</p>
<h5>Basic Administration</h5>
<p>
So to start out I installed Oracle (the only good installation guide was found on a non-Oracle backed
<a href="https://www.codeproject.com/Articles/1027230/Oracle-c-Installation-on-Windows-Step-by-Step">
blog post</a>) and connected to my database instance.  The first task I wanted to accomplish was
create a user for my database schema.  In Oracle a user is an account for
a schema of the same name<sup>1</sup>.
</p>
<p>
I started by creating a tablespace called <code class="jarombek-inline-code">ANDY</code> that I would
place all my tables in.  A tablespace in Oracle consists of physical storage units for the database's
data<sup>2</sup>.  It is a way to group the database at a storage level.
</p>
<CodeSnippet language="SQL">
CREATE TABLESPACE ANDY;

CREATE USER C##ANDYUSR IDENTIFIED BY orac1et3st DEFAULT TABLESPACE ANDY;
GRANT ALL PRIVILEGES TO C##ANDYUSR;
</CodeSnippet>
<p>
Next I create my user <code class="jarombek-inline-code">C##ANDYUSR</code> and give it all privileges.
I also set its default tablespace to the one I just created.  You may be wondering what is up with the
strange username?  The <code class="jarombek-inline-code">C##</code> prefix defines a common user
(contrasted with a local user)<sup>3</sup>.  A common user can be used across all Oracle pluggable
databases instead of being local to a single one.  You can confirm that the user is a common user with
the following query:
</p>
<CodeSnippet language="SQL">
SELECT * FROM ALL_USERS WHERE USERNAME LIKE 'C##%';
</CodeSnippet>
<figure id="common-user-image">
    <img src="common-user.png">
</figure>
<p>
So what is a pluggable database?  It is a new feature in Oracle 12c that allows you to define many
databases inside a container database instance<sup>4</sup>.  This allows for users to control multiple
databases while only running one instance of Oracle 12c.  I am going to ignore the pluggable database
feature for the rest of the discovery but I want to breifly show how you could create a user for a
pluggable database.
</p>
<p>
In SQL*Plus you can change the current session to a pluggable database with the following command:
</p>
<CodeSnippet language="SQL">
alter session set container=CAPYBARA1
</CodeSnippet>
<p>
From here you can simply create a new user like before but without the
<code class="jarombek-inline-code">C##</code> prefix:
</p>
<CodeSnippet language="SQL">
CREATE USER ANDYUSR IDENTIFIED BY orac1et3st DEFAULT TABLESPACE ANDY;
GRANT ALL PRIVILEGES TO ANDYUSR;
</CodeSnippet>
<p>
Now let's move on to building the basic table structure of the database!
</p>
<h5>Table Creation</h5>
<p>
The database is going to store books that I have read.  These books also have a many-to-many relationship
to programming languages (since a book can be about many languages and a language can have many books
describing it).  The first table I added was for languages.
</p>
<CodeSnippet language="SQL">
-- I was thinking of using a sequence to generate a primary key for this table.
-- However, Oracle 12c introduced identity columns which simplifies sequence
-- generation statements on columns
CREATE TABLE languages(
    language_id INTEGER GENERATED BY DEFAULT AS IDENTITY (
    START WITH 1 INCREMENT BY 1
    ),
    name VARCHAR2(63),
    created DATE
) TABLESPACE ANDY;

ALTER TABLE languages ADD CONSTRAINT languages_id_pk PRIMARY KEY (language_id);

-- All language name values must be unique in the table
-- Specifying a unique constraint also creates an index on the column
ALTER TABLE languages ADD CONSTRAINT languages_name_uq UNIQUE (name);
</CodeSnippet>
<p>
Some interesting aspects of this table is that each language has an id that is auto incremented.  This
means that you don't actually assign a language an id, Oracle will generate one for you on request.
</p>
<p>
The second table was for books:
</p>
<CodeSnippet language="SQL">
CREATE TABLE books(
    isbn INTEGER CONSTRAINT books_pk PRIMARY KEY,
    title VARCHAR2(127),
    released DATE
) TABLESPACE ANDY;

-- Since I don't give a name to this constraint, Oracle automatically generates one for me
ALTER TABLE books MODIFY title NOT NULL;

-- Add columns to the existing table
ALTER TABLE books ADD started DATE;
ALTER TABLE books ADD finished DATE;
ALTER TABLE books ADD edition INTEGER;

-- Add a virtual column that determines the number of days spent reading the book
ALTER TABLE books ADD (time_reading AS (finished - started));

-- Add some check constraints to the book table.  This will validate incoming data
ALTER TABLE books ADD CONSTRAINT books_isbn_ck CHECK (isbn > 0);
ALTER TABLE books ADD CONSTRAINT books_dates_ck CHECK (finished >= started);

-- Add indexes on commonly queried columns.
-- Best practice is to create an index when you have queries on a column that
-- retrieve less than 10 percent of the total rows in the table
CREATE INDEX i_books_title ON books(title);
</CodeSnippet>
<p>
The first really cool thing about this table is the <code class="jarombek-inline-code">time_reading</code>
column.  This is a virtual column, a feature added in Oracle 11g.  Virtual columns aren't actually stored
on disk, instead they are dynamically generated by performing computations on other
columns in the table<sup>5</sup>.  The virtual column I defined subtracts the date I started reading from
the date I finished, displaying the number of days spent reading the book!
</p>
<p>
The second cool piece to this table is that some of the columns have <code class="jarombek-inline-code">
CHECK</code> constraints on them.  These constraints enforce rules on the data users try to put into the
columns<sup>6</sup>.  The first constraint makes sure that the ISBN number is
greater than zero, and the second constraint checks that the finished date occurs after (or at the same
time as) the start date.  These <code class="jarombek-inline-code">CHECK</code> constraints allow you
to add some validation logic on database columns!
</p>
<p>
Finally I created the <code class="jarombek-inline-code">book_languages</code> table that stores the many
to many relationship between books and languages:
</p>
<CodeSnippet language="SQL">
CREATE TABLE book_languages(
    isbn INTEGER NOT NULL,
    name VARCHAR2(63),
    CONSTRAINT books_languages_isbn_fk
    FOREIGN KEY (isbn) REFERENCES books(isbn) ON DELETE CASCADE,
    CONSTRAINT book_languages_name_fk
    FOREIGN KEY (name) REFERENCES languages(name) ON DELETE CASCADE
) TABLESPACE ANDY;
</CodeSnippet>
<p>
You can see that both the columns in this table are actually foreign keys by looking at their constraints!
</p>
<h5>Table Population</h5>
<p>
First I populated both the languages and books tables:
</p>
<CodeSnippet language="SQL">
-- Although permitted to do so, do not insert into the auto generated identity column
INSERT INTO languages(
    name, created
) VALUES (
    'Java', '23-MAY-1995'
);

INSERT INTO languages(
    name, created
) VALUES (
    'SQL', '01-JAN-1974'
);

INSERT INTO languages(
    name, created
) VALUES (
    'PL/SQL', '01-JAN-1992'
);

INSERT INTO languages(
    name, created
) VALUES (
    'JavaScript', '04-DEC-1995'
);

-- You are not allowed to insert into virtual columns.  So if you try to insert into
-- time_reading, you get the error:
-- ORA-54013: INSERT operation disallowed on virtual columns
INSERT INTO books(
    isbn, title, released, started, finished, edition
) VALUES (
    9781617291999, 'Java 8 in Action', '01-AUG-2014', '10-OCT-2017', '08-FEB-2018', 1
);

INSERT INTO books(
    isbn, title, released, started, finished, edition
) VALUES (
    9780071799355, 'Oracle Database 12c SQL', '10-SEP-2013', '02-SEP-2017', '28-SEP-2017', 1
);

INSERT INTO books(
    isbn, title, released, started, finished, edition
) VALUES (
    9781491901946, 'AngularJS: Up and Running', '01-SEP-2014', '15-JUN-2017', NULL, 1
);
</CodeSnippet>
<p>
Writing out each insert statement is a bit of overhead, so for the <code class="jarombek-inline-code">
book_languages</code> I created a PL/SQL procedure to do it for me!  In PL/SQL, a procedure is just a
function with no output value.  This is perfect for doing some inserts!
</p>
<CodeSnippet language="SQL">
DECLARE
PROCEDURE bulk_insert(
    p_isbn IN INTEGER,
    p_name IN VARCHAR2
) AS
BEGIN
    INSERT INTO book_languages(
        isbn, name
    ) VALUES (
        p_isbn, p_name
    );
END;
BEGIN
    bulk_insert(p_isbn => 9781617291999, p_name => 'Java');
    bulk_insert(p_isbn => 9780071799355, p_name => 'SQL');
    bulk_insert(p_isbn => 9780071799355, p_name => 'PL/SQL');
    bulk_insert(p_isbn => 9781491901946, p_name => 'JavaScript');
END;

SELECT * FROM book_languages;
</CodeSnippet>
<figure id="bulk-insert-image">
    <img src="bulk-insert.png">
</figure>
<p>
I'll dive more into PL/SQL later.  Now the database is fully set up and ready to query (which I will do
next time).  The full code for this discovery (with some nice comments!) is up on
<a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/02-Feb/
2-12-Oracle-Start/Source">GitHub</a>.
</p>
</div>