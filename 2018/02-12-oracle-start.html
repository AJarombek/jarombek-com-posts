<div>
<p>
I recently finished looking at Java 8 (which was the topic of <a href="https://jarombek.com/blog/feb-7-2018-java8-completable-future">recent</a>
 <a href="https://jarombek.com/blog/feb-8-2018-java8-functional">discoveries</a>) and now I'm switching gears and exploring
the Oracle database.  Although I don't use Oracle a ton in my free time I use it a lot at work
and it is the <a href="http://pypl.github.io/DB.html">most popular database</a> at the moment.  Therefore
its good to know well!
</p>
<p>
This discovery follows the setup of my database.  I will skip the actual Oracle
installation and configuration (which was a challenge itself!) and move straight to the moment I started
typing SQL.
</p>
<p>
A disclaimer before I begin.  A lot of my discoveries are about languages and technologies that I really
love using.  I wouldn't say I love Oracle but it is a good tool to have in the bag.
Just try installing an Oracle product and you will see why many get frustrated with this
database!  One bright spot is the PL/SQL language, which allows developers to add some
really cool functionality at the database layer of applications.  I won't go into PL/SQL much
this time around but definitely will in the future!
</p>
<SectionTitle title="Basic Administration">Basic Administration</SectionTitle>
<p>
To start I installed Oracle (the only good installation guide I could find was in a non-Oracle backed
<a href="https://www.codeproject.com/Articles/1027230/Oracle-c-Installation-on-Windows-Step-by-Step">
blog post</a>) and connected to my database instance.  The first task I wanted to accomplish was
creating a user for my database schema.  In Oracle a user is an account for
a schema of the same name<sup>1</sup>.
</p>
<p>
I created a tablespace called <code className="jarombek-inline-code">ANDY</code> for all my
tables.  A tablespace in Oracle consists of physical storage units for the database's
data<sup>2</sup>.  It is a way to group the database at the storage level.
</p>
<CodeSnippet language="SQL">
CREATE TABLESPACE ANDY;

CREATE USER C##ANDYUSR IDENTIFIED BY orac1et3st DEFAULT TABLESPACE ANDY;
GRANT ALL PRIVILEGES TO C##ANDYUSR;
</CodeSnippet>
<p>
Next I created my user <code className="jarombek-inline-code">C##ANDYUSR</code> and gave it all privileges.
I also set its default tablespace to the one I just created.  You may be wondering what is up with the
strange username.  The <code className="jarombek-inline-code">C##</code> prefix defines a common user
(contrasted with a local user)<sup>3</sup>.  A common user is accessible across all Oracle pluggable
databases instead of being local to a single one.  You can confirm the user is a common user with
the following query:
</p>
<CodeSnippet language="SQL">
SELECT * FROM ALL_USERS WHERE USERNAME LIKE 'C##%';
</CodeSnippet>
<figure id="common-user-image">
    <img className="jarombek-blog-image" src="https://asset.jarombek.com/common-user.png">
</figure>
<p>
So what is a pluggable database?  It is a new feature in Oracle 12c that allows you to define many
databases inside a container database instance<sup>4</sup>.  This allows users to control multiple
databases while only running one instance of Oracle 12c.  I'm going to ignore pluggable databases
for the rest of this article, but I'll briefly show how to create a user for a pluggable database.
</p>
<p>
In SQL*Plus the following command changes the current session to a pluggable database:
</p>
<CodeSnippet language="SQL">
alter session set container=CAPYBARA1
</CodeSnippet>
<p>
From here a pluggable database user is created like before but without the <code className="jarombek-inline-code">C##</code> prefix:
</p>
<CodeSnippet language="SQL">
CREATE USER ANDYUSR IDENTIFIED BY orac1et3st DEFAULT TABLESPACE ANDY;
GRANT ALL PRIVILEGES TO ANDYUSR;
</CodeSnippet>
<p>
Now let's move on to building the basic table structure of the database!
</p>
<SectionTitle title="Table Creation">Table Creation</SectionTitle>
<p>
The database stores books that I have read.  These books have a many-to-many relationship
to programming languages (since a book can be about many languages and a language can have many books
describing it).  The first table I added was <code className="jarombek-inline-code">languages</code>.
</p>
<CodeSnippet language="SQL">
-- I was thinking of using a sequence to generate a primary key for this table.
-- However, Oracle 12c introduced identity columns which simplifies sequence
-- generation statements on columns
CREATE TABLE languages(
    language_id INTEGER GENERATED BY DEFAULT AS IDENTITY (
        START WITH 1 INCREMENT BY 1
    ),
    name VARCHAR2(63),
    created DATE
) TABLESPACE ANDY;

ALTER TABLE languages ADD CONSTRAINT languages_id_pk PRIMARY KEY (language_id);

-- All language name values must be unique in the table
-- Specifying a unique constraint also creates an index on the column
ALTER TABLE languages ADD CONSTRAINT languages_name_uq UNIQUE (name);
</CodeSnippet>
<p>
One interesting aspect of this table is that each language has an id that is auto incremented.  This
means that languages aren't manually assigned an id, instead Oracle generates one on request.
</p>
<p>
The second table is for books:
</p>
<CodeSnippet language="SQL">
CREATE TABLE books(
    isbn INTEGER CONSTRAINT books_pk PRIMARY KEY,
    title VARCHAR2(127),
    released DATE
) TABLESPACE ANDY;

-- Since I don't give a name to this constraint, Oracle automatically generates one for me
ALTER TABLE books MODIFY title NOT NULL;

-- Add columns to the existing table
ALTER TABLE books ADD started DATE;
ALTER TABLE books ADD finished DATE;
ALTER TABLE books ADD edition INTEGER;

-- Add a virtual column that determines the number of days spent reading the book
ALTER TABLE books ADD (time_reading AS (finished - started));

-- Add some check constraints to the book table.  This will validate incoming data
ALTER TABLE books ADD CONSTRAINT books_isbn_ck CHECK (isbn > 0);
ALTER TABLE books ADD CONSTRAINT books_dates_ck CHECK (finished >= started);

-- Add indexes on commonly queried columns.
-- Best practice is to create an index when you have queries on a column that
-- retrieve less than 10 percent of the total rows in the table
CREATE INDEX i_books_title ON books(title);
</CodeSnippet>
<p>
The first really cool thing about this table is the <code className="jarombek-inline-code">time_reading</code>
column.  This is a virtual column, a feature added in Oracle 11g.  Virtual columns aren't stored
on disk, instead they are dynamically generated by performing computations on other
columns in the table<sup>5</sup>.  The virtual column I defined subtracts the date I started reading from
the date I finished, displaying the number of days spent reading the book!
</p>
<p>
The second cool piece to this table is that some of the columns have <code className="jarombek-inline-code">
CHECK</code> constraints on them.  These constraints enforce rules on the data that users try inserting into
columns<sup>6</sup>.  The first constraint makes sure that the ISBN number is
greater than zero, and the second constraint checks that the finished date occurs after (or at the same
time as) the start date.  These <code className="jarombek-inline-code">CHECK</code> constraints allow you
to add some validation logic on database columns!
</p>
<p>
Finally I created a <code className="jarombek-inline-code">book_languages</code> table that stores a many
to many relationship between books and languages:
</p>
<CodeSnippet language="SQL">
CREATE TABLE book_languages(
    isbn INTEGER NOT NULL,
    name VARCHAR2(63),
    CONSTRAINT books_languages_isbn_fk
        FOREIGN KEY (isbn) REFERENCES books(isbn) ON DELETE CASCADE,
    CONSTRAINT book_languages_name_fk
        FOREIGN KEY (name) REFERENCES languages(name) ON DELETE CASCADE
) TABLESPACE ANDY;
</CodeSnippet>
<p>
The table constraints define both the columns as foreign keys!
</p>
<SectionTitle title="Table Population">Table Population</SectionTitle>
<p>
First I populated both the languages and books tables:
</p>
<CodeSnippet language="SQL">
-- Although permitted to do so, do not insert into the auto generated identity column
INSERT INTO languages(
    name, created
) VALUES (
    'Java', '23-MAY-1995'
);

INSERT INTO languages(
    name, created
) VALUES (
    'SQL', '01-JAN-1974'
);

INSERT INTO languages(
    name, created
) VALUES (
    'PL/SQL', '01-JAN-1992'
);

INSERT INTO languages(
    name, created
) VALUES (
    'JavaScript', '04-DEC-1995'
);

-- You are not allowed to insert into virtual columns.  So if you try to insert into
-- time_reading, you get the error:
-- ORA-54013: INSERT operation disallowed on virtual columns
INSERT INTO books(
    isbn, title, released, started, finished, edition
) VALUES (
    9781617291999, 'Java 8 in Action', '01-AUG-2014', '10-OCT-2017', '08-FEB-2018', 1
);

INSERT INTO books(
    isbn, title, released, started, finished, edition
) VALUES (
    9780071799355, 'Oracle Database 12c SQL', '10-SEP-2013', '02-SEP-2017', '28-SEP-2017', 1
);

INSERT INTO books(
    isbn, title, released, started, finished, edition
) VALUES (
    9781491901946, 'AngularJS: Up and Running', '01-SEP-2014', '15-JUN-2017', NULL, 1
);
</CodeSnippet>
<p>
Writing out each insert statement requires a bit of overhead, so for the <code className="jarombek-inline-code">
book_languages</code> table I created a PL/SQL procedure to do it for me!  In PL/SQL, a procedure is just a
function with no output value.  This is perfect for doing some inserts!
</p>
<CodeSnippet language="SQL">
DECLARE
PROCEDURE bulk_insert(
    p_isbn IN INTEGER,
    p_name IN VARCHAR2
) AS
BEGIN
    INSERT INTO book_languages(
        isbn, name
    ) VALUES (
        p_isbn, p_name
    );
END;
BEGIN
    bulk_insert(p_isbn => 9781617291999, p_name => 'Java');
    bulk_insert(p_isbn => 9780071799355, p_name => 'SQL');
    bulk_insert(p_isbn => 9780071799355, p_name => 'PL/SQL');
    bulk_insert(p_isbn => 9781491901946, p_name => 'JavaScript');
END;

SELECT * FROM book_languages;
</CodeSnippet>
<figure id="bulk-insert-image">
    <img className="jarombek-blog-image" src="https://asset.jarombek.com/bulk-insert.png">
</figure>
<p>
I'll look into PL/SQL later.  Now the database is fully set up and ready to query (which I will do
<a href="https://jarombek.com/blog/mar-2-2018-oracle-queries">next time</a>).  The full code for this discovery (with some nice comments!) is up on
<a href="https://github.com/AJarombek/jarombek-com-sources/tree/master/2018/02-Feb/2-12-Oracle-Start">GitHub</a>.
</p>
</div>