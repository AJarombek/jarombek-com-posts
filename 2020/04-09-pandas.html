<div>
<p>
In my <a href="https://jarombek.com/blog/mar-31-2020-numpy">previous article</a> I walked through
interesting aspects of numpy.  I first learned numpy back in college during a course on Artificial
Intelligence.  With my daytime work becoming more Python based these past few months, I took numpy back up.
</p>
<p>
Before this winter, I never used pandas.  Pandas is a data analysis library similar to numpy.  In fact,
pandas uses numpy arrays in many of its exposed methods.  While numpy exposes an array data structure,
pandas has two main data structures: <code className="jarombek-inline-code">Series</code> and
<code className="jarombek-inline-code">DataFrame</code>.  In general, pandas is commonly used for
manipulating and analysing time series or table data (think SQL table or excel spreadsheet)<sup>1</sup>.
</p>
<p>
Just like numpy, I wanted to write an article about the interesting aspects of pandas.  I’ve read
thoroughly about pandas and coded with it at my job, and want to share some of my favorite features.
This article isn’t meant to teach pandas basics, instead highlighting what makes pandas unique and
special compared to other libraries and languages.
</p>
<SectionTitle title="What is Pandas">What is Pandas?</SectionTitle>
<p>
Pandas is a Python library used for data analysis, commonly on table and time series data.  Pandas was
originally built to work with financial data, however its modern use cases are vast in number<sup>2</sup>.
Software engineering fields that use pandas include machine learning, economics, stock picking algorithms,
and big data<sup>3</sup>.
</p>
<p>
Pandas has two main data types - <code>Series</code> and <code>DataFrame</code>.  A series is a
single-dimensional data structure containing an array of data and an array of labels<sup>4</sup>.  Each
label is associated with an element in the data array.  This array of labels is called the index, and
is of type <code>Index</code>.  Listed below are two examples of the <code>Series</code> data structure,
along with ways to access their indexes.
</p>
<CodeSnippet language="Python">
import pandas as pd

series = pd.Series([1, 2, 3, 4, 5])
series

# Out[1]:
#    0    1
#	   1    2
#    2    3
#	   3    4
#	   4    5
#	   dtype: int64

series.index

# Out[2]: RangeIndex(start=0, stop=5, step=1)

series = pd.Series([1, 2, 3], index=['c', 'b', 'a'])
series

# Out[3]:
#    c    1
#    b    2
#    a    3
#    dtype: int64

series.index

# Out[4]: Index(['c', 'b', 'a'], dtype='object')
</CodeSnippet>
<p>
The first series implicitly defines the index while the second series explicitly passes the
<code className="jarombek-inline-code">index</code> argument to the
<code className="jarombek-inline-code">Series()</code> constructor.  The first series’
<code className="jarombek-inline-code">RangeIndex</code> is a subtype of
<code className="jarombek-inline-code">Index</code> which holds a range of integers.
</p>
<p>
A data frame contains columns and rows of data, just like a table<sup>5</sup>.  Data frames also have
an index for the rows and column names for the columns.  There are many ways to create
<code className="jarombek-inline-code">DataFrame</code> objects, with the most basic method being to
pass its constructor a dictionary.  The following <code className="jarombek-inline-code">DataFrame</code>
represents some workouts I did back in February.
</p>
<CodeSnippet language="Python">
runs = {
  'user': ['andy', 'andy', 'andy'],
  'type': ['run', 'core', 'run'],
  'date': ['02-19-2020', '02-19-2020', '02-18-2020'],
  'time': ['20:15', '8:00', '16:00']
}
frame = pd.DataFrame(runs)
frame

# Out[5]:
# |   | user | type | date       | time  |
# +---+------+------+------------+-------+
# | 0 | andy | run  | 02-19-2020 | 20:15 |
# | 1 | andy | core | 02-19-2020 | 8:00  |
# | 2 | andy | run  | 02-18-2020 | 16:00 |
</CodeSnippet>
<p>
The remainder of this article discusses aspects of pandas that I found most interesting.
</p>
<SectionTitle title="Similarities to R">Similarities to R</SectionTitle>
<p>
Pandas has many similarities to the R programming language, most noticeably its
<code className="jarombek-inline-code">DataFrame</code> object.  In R,
<code className="jarombek-inline-code">data.frame</code> is a fundamental built-in object with similar
functionality to pandas’ <code className="jarombek-inline-code">DataFrame</code><sup>6,7</sup>.  The
following data frame in R is nearly identical to the one in Python with pandas.
</p>
<CodeSnippet language="R">
user <- c("andy", "andy", "andy")
type <- c("run", "core", "run")
date <- c("02-19-2020", "02-19-2020", "02-18-2020")
time <- c("20:15", "8:00", "16:00")

exercises <- data.frame(user, type, date, time)
print(exercises)

#   user type       date  time
# 1 andy  run 02-19-2020 20:15
# 2 andy core 02-19-2020  8:00
# 3 andy  run 02-18-2020 16:00
</CodeSnippet>
<p>
R is a domain-specific programming language for data analysis and statistical computing.  Although not
explicitly documented as true, the R programming language seems to have inspired the creation of pandas
(and numpy).  For example, R has array vectorization and conditional indexing, features found in both
pandas and numpy (although noticeably missing from the base Python language).  The following code sample
demonstrates vectorization operations in R:
</p>
<CodeSnippet language="R">
vec1 <- c(1, 2, 3)
vec2 <- c(3, 2, 1)

# Perform addition of two vectors.
result_vec <- vec1 + vec2
result_vec

# [1] 4 4 4
</CodeSnippet>
<p>
Conditional indexing is shown below:
</p>
<CodeSnippet language="R">
# Create a range vector
vec3 <- c(1:10)

onlygt2 <- vec3[vec3 > 2]
print(onlygt2)

# [1]  3  4  5  6  7  8  9 10
</CodeSnippet>
<p>
I find it fascinating to compare languages and frameworks to see where features and ideas originated from.
Although pandas and numpy were influenced heavily by prior tools and languages, their ease of use within
the Python ecosystem is what makes them so valuable.
</p>
<SectionTitle title="DataFrame Creation">DataFrame Creation</SectionTitle>
<p>
One of the great things about pandas is the multitude of ways to initialize a
<code className="jarombek-inline-code">DataFrame</code> or <code className="jarombek-inline-code">Series</code>.
In software engineering, it's generally a good idea when building an API to not assume the existing
format of a user's data.  For example, in Java, APIs that accept a data structure as an argument often
declare their parameters as type <code className="jarombek-inline-code">Iterable&lt;T&gt;</code>.  By
using the <code className="jarombek-inline-code">Iterable&lt;T&gt;</code> interface, a user can pass
whatever iterable structure their data already exists in, whether it be a list, set, queue, stack, tree,
or something else<sup>8</sup>.  All these data structures implement
<code className="jarombek-inline-code">Iterable&lt;T&gt;</code>, so they work with the API.
</p>
<p>
Pandas takes this concept to another level.  Not only does the
<code className="jarombek-inline-code">DataFrame</code> constructor and accompanying static factory
methods accept multiple Python data structures as arguments, they also accept many different file formats.
For example, CSV files can be turned into a data frame with <code className="jarombek-inline-code">
read_csv()</code> and database tables can be turned into a data frame with
<code className="jarombek-inline-code">read_sql_table</code>.  Other file formats that are easily turned
into a data frame include Excel spreadsheets, HTML, and JSON.  A full list of
<code className="jarombek-inline-code">DataFrame</code> input formats is found in the
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/io.html">pandas documentation</a>.
</p>
<SectionTitle title="Indexing Slicing and Manipulation">Indexing, Slicing, & Manipulation</SectionTitle>
<p>
In my previous article on <a href="https://jarombek.com/blog/mar-31-2020-numpy#enhanced-slicing">numpy</a>
I discussed its advanced slicing and indexing mechanics.  Pandas has similar functionality for its
<code className="jarombek-inline-code">Series</code> and
<code className="jarombek-inline-code">DataFrame</code> objects.  First, here are some indexing and slicing examples on <code className="jarombek-inline-code">Series</code> data structures.
</p>
<CodeSnippet language="Python">
series = pd.Series([1, 2, 3], index=['c', 'b', 'a'])
series

# Out[6]:
#    c    1
#    b    2
#    a    3
#    dtype: int64

series[1]

# Out[7]: 2

series['b']

# Out[8]: 2

series[['a', 'b']]

# Out[9]:
#    a    3
#    b    2
#    dtype: int64

series[['b', 'b']]

# Out[10]:
#    b    2
#    b    2
#    dtype: int64

# Indexes can be checked for existence with 'in' ...
'a' in series

# Out[11]: True

# ... values can not.
1 in series

# Out[12]: False
</CodeSnippet>
<SectionTitle title="Time Series Data">Time Series Data</SectionTitle>
<SectionTitle title="Advanced Data Manipulation with Group By">Advanced Data Manipulation with Group By</SectionTitle>
<SectionTitle title="Conclusions">Conclusions</SectionTitle>
</div>
