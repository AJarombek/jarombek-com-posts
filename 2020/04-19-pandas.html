<div>
<p>
In my <a href="https://jarombek.com/blog/mar-31-2020-numpy">previous article</a> I walked through
interesting aspects of numpy.  I first learned numpy back in college during a course on Artificial
Intelligence.  With my daytime work becoming more Python based these past few months, I took numpy back up.
</p>
<p>
Before this winter, I never used pandas.  Pandas is a data analysis library similar to numpy.  In fact,
pandas uses numpy arrays in many of its exposed methods.  While numpy exposes an array data structure,
pandas has two main data structures: <code className="jarombek-inline-code">Series</code> and
<code className="jarombek-inline-code">DataFrame</code>.  In general, pandas is commonly used for
manipulating and analysing time series or table data (think SQL table or excel spreadsheet)<sup>1</sup>.
</p>
<p>
Just like numpy, I wanted to write an article about the interesting aspects of pandas.  I’ve read
thoroughly about pandas and coded with it at my job, and want to share some of my favorite features.
This article isn’t meant to teach pandas basics, instead highlighting what makes pandas unique and
special compared to other libraries and languages.
</p>
<SectionTitle title="What is Pandas">What is Pandas?</SectionTitle>
<p>
Pandas is a Python library used for data analysis, commonly on table and time series data.  Pandas was
originally built to work with financial data, however its modern use cases are vast in number<sup>2</sup>.
Software engineering fields that use pandas include machine learning, economics, stock picking algorithms,
and big data<sup>3</sup>.
</p>
<p>
Pandas has two main data types - <code>Series</code> and <code>DataFrame</code>.  A series is a
single-dimensional data structure containing an array of data and an array of labels<sup>4</sup>.  Each
label is associated with an element in the data array.  This array of labels is called the index, and
is of type <code>Index</code>.  Listed below are two examples of the <code>Series</code> data structure,
along with ways to access their indexes.
</p>
<CodeSnippet language="Python">
import pandas as pd

series = pd.Series([1, 2, 3, 4, 5])
series

# Out[1]:
#    0    1
#	   1    2
#    2    3
#	   3    4
#	   4    5
#	   dtype: int64

series.index

# Out[2]: RangeIndex(start=0, stop=5, step=1)

series = pd.Series([1, 2, 3], index=['c', 'b', 'a'])
series

# Out[3]:
#    c    1
#    b    2
#    a    3
#    dtype: int64

series.index

# Out[4]: Index(['c', 'b', 'a'], dtype='object')
</CodeSnippet>
<p>
The first series implicitly defines the index while the second series explicitly passes the
<code className="jarombek-inline-code">index</code> argument to the
<code className="jarombek-inline-code">Series()</code> constructor.  The first series’
<code className="jarombek-inline-code">RangeIndex</code> is a subtype of
<code className="jarombek-inline-code">Index</code> which holds a range of integers.
</p>
<p>
A data frame contains columns and rows of data, just like a table<sup>5</sup>.  Data frames also have
an index for the rows and column names for the columns.  There are many ways to create
<code className="jarombek-inline-code">DataFrame</code> objects, with the most basic method being to
pass its constructor a dictionary.  The following <code className="jarombek-inline-code">DataFrame</code>
represents some workouts I did back in February.
</p>
<CodeSnippet language="Python">
runs = {
  'user': ['andy', 'andy', 'andy'],
  'type': ['run', 'core', 'run'],
  'date': ['02-19-2020', '02-19-2020', '02-18-2020'],
  'time': ['20:15', '8:00', '16:00']
}
frame = pd.DataFrame(runs)
frame

# Out[5]:
# |   | user | type | date       | time  |
# +---+------+------+------------+-------+
# | 0 | andy | run  | 02-19-2020 | 20:15 |
# | 1 | andy | core | 02-19-2020 | 8:00  |
# | 2 | andy | run  | 02-18-2020 | 16:00 |
</CodeSnippet>
<p>
The remainder of this article discusses aspects of pandas that I found most interesting.
</p>
<SectionTitle title="Similarities to R">Similarities to R</SectionTitle>
<p>
Pandas has many similarities to the R programming language, most noticeably its
<code className="jarombek-inline-code">DataFrame</code> object.  In R,
<code className="jarombek-inline-code">data.frame</code> is a fundamental built-in object with similar
functionality to pandas’ <code className="jarombek-inline-code">DataFrame</code><sup>6,7</sup>.  The
following data frame in R is nearly identical to the one in Python with pandas.
</p>
<CodeSnippet language="R">
user <- c("andy", "andy", "andy")
type <- c("run", "core", "run")
date <- c("02-19-2020", "02-19-2020", "02-18-2020")
time <- c("20:15", "8:00", "16:00")

exercises <- data.frame(user, type, date, time)
print(exercises)

#   user type       date  time
# 1 andy  run 02-19-2020 20:15
# 2 andy core 02-19-2020  8:00
# 3 andy  run 02-18-2020 16:00
</CodeSnippet>
<p>
R is a domain-specific programming language for data analysis and statistical computing.  Although not
explicitly documented as true, the R programming language seems to have inspired the creation of pandas
(and numpy).  For example, R has array vectorization and conditional indexing, features found in both
pandas and numpy (although noticeably missing from the base Python language).  The following code sample
demonstrates vectorization operations in R:
</p>
<CodeSnippet language="R">
vec1 <- c(1, 2, 3)
vec2 <- c(3, 2, 1)

# Perform addition of two vectors.
result_vec <- vec1 + vec2
result_vec

# [1] 4 4 4
</CodeSnippet>
<p>
Conditional indexing is shown below:
</p>
<CodeSnippet language="R">
# Create a range vector
vec3 <- c(1:10)

onlygt2 <- vec3[vec3 > 2]
print(onlygt2)

# [1]  3  4  5  6  7  8  9 10
</CodeSnippet>
<p>
I find it fascinating to compare languages and frameworks to see where features and ideas originated from.
Although pandas and numpy were influenced heavily by prior tools and languages, their ease of use within
the Python ecosystem is what makes them so valuable.
</p>
<SectionTitle title="DataFrame Creation">DataFrame Creation</SectionTitle>
<p>
One of the great things about pandas is the multitude of ways to initialize a
<code className="jarombek-inline-code">DataFrame</code> or <code className="jarombek-inline-code">Series</code>.
In software engineering, it's generally a good idea when building an API to not assume the existing
format of a user's data.  For example, in Java, APIs that accept a data structure as an argument often
declare their parameters as type <code className="jarombek-inline-code">Iterable&lt;T&gt;</code>.  By
using the <code className="jarombek-inline-code">Iterable&lt;T&gt;</code> interface, a user can pass
whatever iterable structure their data already exists in, whether it be a list, set, queue, stack, tree,
or something else<sup>8</sup>.  All these data structures implement
<code className="jarombek-inline-code">Iterable&lt;T&gt;</code>, so they work with the API.
</p>
<p>
Pandas takes this concept to another level.  Not only does the
<code className="jarombek-inline-code">DataFrame</code> constructor and accompanying static factory
methods accept multiple Python data structures as arguments, they also accept many different file formats.
For example, CSV files can be turned into a data frame with <code className="jarombek-inline-code">
read_csv()</code> and database tables can be turned into a data frame with
<code className="jarombek-inline-code">read_sql_table</code>.  Other file formats that are easily turned
into a data frame include Excel spreadsheets, HTML, and JSON.  A full list of
<code className="jarombek-inline-code">DataFrame</code> input formats is found in the
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/io.html">pandas documentation</a>.
</p>
<SectionTitle title="Indexing Slicing and Manipulation">Indexing, Slicing, and Manipulation</SectionTitle>
<p>
In my previous article on <a href="https://jarombek.com/blog/mar-31-2020-numpy#enhanced-slicing">numpy</a>
I discussed its advanced slicing and indexing mechanics.  Pandas has similar functionality for its
<code className="jarombek-inline-code">Series</code> and
<code className="jarombek-inline-code">DataFrame</code> objects.  First, here are some indexing and slicing examples on <code className="jarombek-inline-code">Series</code> data structures.
</p>
<CodeSnippet language="Python">
series = pd.Series([1, 2, 3], index=['c', 'b', 'a'])
series

# Out[6]:
#    c    1
#    b    2
#    a    3
#    dtype: int64

series[1]

# Out[7]: 2

series['b']

# Out[8]: 2

series[['a', 'b']]

# Out[9]:
#    a    3
#    b    2
#    dtype: int64

series[['b', 'b']]

# Out[10]:
#    b    2
#    b    2
#    dtype: int64

# Indexes can be checked for existence with 'in' ...
'a' in series

# Out[11]: True

# ... values can not.
1 in series

# Out[12]: False
</CodeSnippet>
<p>
The same slicing and indexing functionality is available for
<code className="jarombek-inline-code">DataFrame</code> objects.  The following data frame contains
running PR (personal record) information for some of my friends and I in college.
</p>
<CodeSnippet language="Python">
data_xctf = {
  '8K': ['24:20.80', '24:33.50', '24:58.80', None, '26:24.20'],
  '6K': ['18:58.80', '19:10.20', '19:25.80', '20:54.00', '20:20.50'],
  '5K': ['15:32.00', '15:39.00', '15:59.00', '17:31.60', '16:38.40'],
  '10000m': [None, None, '31:51.73', '35:50.22', None],
  '5000m': ['14:23.21', None, '15:27.01', '16:44.14', '15:27.64'],
  '3000m': ['8:32.83', '8:52.60', '8:51.80', '9:47.70', '9:03.60'],
  '1 Mile': ['4:20.59', '4:20.39', '4:40.34', '4:57.53', '4:40.76'],
  '1500m': ['3:54.67', '3:57.78', None, '4:32.14', '4:08.17']
}
run_dataframe = pd.DataFrame(data_xctf, index=['Thomas Caulfield', 'Joseph Smith', 'Ben Fishbein', 'Lisa Grohn', 'Andy Jarombek'])
run_dataframe

Out[13]:
# |                  | 8K       | 6K       | 5K       | 10000m   | 5000m    | 3000m   | 1 Mile  | 1500m   |
# +------------------+----------+----------+----------+----------+----------+---------+---------+---------+
# | Thomas Caulfield | 24:20.80 | 18:58.80 | 15:32.00 | None     | 14:23.21 | 8:32.83 | 4:20.59 | 3:54.67 |
# | Joseph Smith     | 24:33.50 | 19:10.20 | 15:39.00 | None     | None     | 8:52.60 | 4:20.39 | 3:57.78 |
# | Ben Fishbein     | 24:58.80 | 19:25.80 | 15:59.00 | 31:51.73 | 15:27.01 | 8:51.80 | 4:40.34 | None    |
# | Lisa Grohn       | None     | 20:54.00 | 17:31.60 | 35:50.22 | 16:44.14 | 9:47.70 | 4:57.53 | 4:32.14 |
# | Andy Jarombek    | 26:24.20 | 20:20.50 | 16:38.40 | None     | 15:27.64 | 9:03.60 | 4:40.76 | 4:08.17 |
</CodeSnippet>
<p>
Now, here are some slicing and indexing operations on the data frame.
</p>
<CodeSnippet language="Python">
# Rows can be sliced by index name...
run_dataframe['Joseph Smith':'Lisa Grohn']

# Out[14]:
# |                  | 8K       | 6K       | 5K       | 10000m   | 5000m    | 3000m   | 1 Mile  | 1500m   |
# +------------------+----------+----------+----------+----------+----------+---------+---------+---------+
# | Joseph Smith     | 24:33.50 | 19:10.20 | 15:39.00 | None     | None     | 8:52.60 | 4:20.39 | 3:57.78 |
# | Ben Fishbein     | 24:58.80 | 19:25.80 | 15:59.00 | 31:51.73 | 15:27.01 | 8:51.80 | 4:40.34 | None    |
# | Lisa Grohn       | None     | 20:54.00 | 17:31.60 | 35:50.22 | 16:44.14 | 9:47.70 | 4:57.53 | 4:32.14 |

# ...or by index location.
run_dataframe[1:3]

# Out[15]:
# |                  | 8K       | 6K       | 5K       | 10000m   | 5000m    | 3000m   | 1 Mile  | 1500m   |
# +------------------+----------+----------+----------+----------+----------+---------+---------+---------+
# | Joseph Smith     | 24:33.50 | 19:10.20 | 15:39.00 | None     | None     | 8:52.60 | 4:20.39 | 3:57.78 |
# | Ben Fishbein     | 24:58.80 | 19:25.80 | 15:59.00 | 31:51.73 | 15:27.01 | 8:51.80 | 4:40.34 | None    |

# Columns can also be sliced by column name...
run_dataframe.loc[:, ['8K', '6K', '5K']]

# Out[16]:
# |                  | 8K       | 6K       | 5K       |
# +------------------+----------+----------+----------+
# | Thomas Caulfield | 24:20.80 | 18:58.80 | 15:32.00 |
# | Joseph Smith     | 24:33.50 | 19:10.20 | 15:39.00 |
# | Ben Fishbein     | 24:58.80 | 19:25.80 | 15:59.00 |
# | Lisa Grohn       | None     | 20:54.00 | 17:31.60 |
# | Andy Jarombek    | 26:24.20 | 20:20.50 | 16:38.40 |

# ...or by column location.
run_dataframe.iloc[:, [0, 2]]

# Out[17]:
# |                  | 8K       | 5K       |
# +------------------+----------+----------+
# | Thomas Caulfield | 24:20.80 | 15:32.00 |
# | Joseph Smith     | 24:33.50 | 15:39.00 |
# | Ben Fishbein     | 24:58.80 | 15:59.00 |
# | Lisa Grohn       | None     | 17:31.60 |
# | Andy Jarombek    | 26:24.20 | 16:38.40 |

# Slicing can be done on both rows and columns at the same time.
run_dataframe.iloc[3, [0, 1, 2]]

# Out[18]:
# 8K        None
# 6K    20:54.00
# 5K    17:31.60
# Name: Lisa Grohn, dtype: object

# Picking rows and columns for the resulting frame.  Results in Men's Track & Field PRs.
run_dataframe.iloc[np.array([0, 1, 2, 4]), np.arange(3, 8)]

# Out[19]:
# |                  | 10000m   | 5000m    | 3000m   | 1 Mile  | 1500m   |
# +------------------+----------+----------+---------+---------+---------+
# | Thomas Caulfield | None     | 14:23.21 | 8:32.83 | 4:20.59 | 3:54.67 |
# | Joseph Smith     | None     | None     | 8:52.60 | 4:20.39 | 3:57.78 |
# | Ben Fishbein     | 31:51.73 | 15:27.01 | 8:51.80 | 4:40.34 | None    |
# | Andy Jarombek    | None     | 15:27.64 | 9:03.60 | 4:40.76 | 4:08.17 |

# Indexing can also be performed with index and column names...
run_dataframe.at['Thomas Caulfield', '5000m']

# Out[20]: '14:23.21'

# ...or with index and column locations.
run_dataframe.iat[0, 4]

# Out[21]: '14:23.21'
</CodeSnippet>
<p>
An important takeaway from these code samples is that indexing and slicing in pandas is just as powerful
as numpy, with the added benefit of a tabular <code className="jarombek-inline-code">DataFrame</code>
data structure.  Pandas also exposes many ways to manipulate data, from simple vectorization operations to
complex "group by" expressions (which I will explain later).  Some simple data manipulation examples are
shown below.
</p>
<CodeSnippet language="Python">
data_xctf = {
  '8K': [1460.80, 1473.50, 1498.80, np.nan, 1584.20],
  '6K': [1138.80, 1150.20, 1165.80, 1254.00, 1220.50],
  '5K': [932.00, 939.00, 959.00, 1051.60, 998.40]
}
run_sec_dataframe = pd.DataFrame(data_xctf, index=['Thomas Caulfield', 'Joseph Smith', 'Ben Fishbein', 'Lisa Grohn', 'Andy Jarombek'])
run_sec_dataframe

# Out[22]:
# |                  | 8K       | 6K       | 5K       |
# +------------------+----------+----------+----------+
# | Thomas Caulfield | 1460.8   | 1138.8   | 932.0    |
# | Joseph Smith     | 1473.5   | 1150.2   | 939.0    |
# | Ben Fishbein     | 1498.8   | 1165.8   | 959.0    |
# | Lisa Grohn       | None     | 1254.0   | 1051.6   |
# | Andy Jarombek    | 1584.2   | 1220.5   | 998.4    |

# Vectorization on two Series objects.  Computes Tom and Joe's combined seconds for races.
run_sec_dataframe.iloc[0] + run_sec_dataframe.iloc[1]

# Out[23]:
# 8K    2934.3
# 6K    2289.0
# 5K    1871.0
# dtype: float64

# Vectorization on a DataFrame object which is first sliced.  Computes everyones 400m pace for the 6K.
run_sec_dataframe.loc[:, ['6K']] / 15

# Out[24]:
# |                  | 6K      |
# +------------------+---------+
# | Thomas Caulfield | 75.92   |
# | Joseph Smith     | 76.68   |
# | Ben Fishbein     | 77.72   |
# | Lisa Grohn       | 83.60   |
# | Andy Jarombek    | 81.37   |

# Vectorization on a DataFrame.  Pace per 400m for each race.
run_sec_dataframe / [20, 15, 12.5]

# Out[25]:
# |                  | 8K      | 6K      | 5K       |
# +------------------+---------+---------+----------+
# | Thomas Caulfield | 73.04   | 75.92   | 74.56    |
# | Joseph Smith     | 73.67   | 76.68   | 75.12    |
# | Ben Fishbein     | 74.94   | 77.72   | 76.72    |
# | Lisa Grohn       | None    | 83.60   | 84.13    |
# | Andy Jarombek    | 79.21   | 81.37   | 79.87    |

# Transpose a DataFrame by swapping its rows and columns.
run_sec_dataframe.T

# Out[26]:
# |    | Thomas Caulfield | Joseph Smith | Ben Fishbein | Lisa Grohn | Andy Jarombek |
# +----+------------------+--------------+--------------+------------+---------------+
# | 8K | 1460.8           | 1473.5       | 1498.8       | None       | 1584.2        |
# | 6K | 1138.8           | 1150.2       | 1165.8       | 1254.0     | 1220.5        |
# | 5K | 932.0            | 939.0        | 959.0        | 1051.6     | 998.4         |

# Series and DataFrame types have methods for each arithmetic operation.
# These can be used instead of vectorization.
run_seconds_dataframe.loc['5K'].div(25)

# Out[27]:
# Thomas Caulfield    37.280
# Joseph Smith        37.560
# Ben Fishbein        38.360
# Lisa Grohn          42.064
# Andy Jarombek       39.936
# Name: 5K, dtype: float64
</CodeSnippet>
<p>
There are so many examples of pandas <code className="jarombek-inline-code">DataFrame</code> manipulation
operations, but these are some of the most basic ones.  I’m trying to demonstrate that
<code className="jarombek-inline-code">DataFrame</code> objects aren't simply for holding data, but also
transforming it and analyzing it in whatever way suits an application's needs.  Pandas provides plenty
of statistical operations as well, such as finding the sum or standard deviation of data.  Math isn’t
my strong suit so I won’t go over any statistical functions, but they are readily available and easy to use.
</p>
<SectionTitle title="Time Series Data">Time Series Data</SectionTitle>
<p>
Along with tabular data, another common use case for pandas is holding time series data.  Pandas has the
strongest time-series functionality I’ve ever seen in a language or library, which is quite exciting!
</p>
<p>
Dealing with dates and times in programming languages is often a frustrating experience.  When creating a
library that handles dates and times, it's crucial that the basic API is easy to use and intuitive.
Otherwise, date and time complexities such as timezones and daylight savings time become a nightmare to
deal with.  For an example of a poorly made date library, see the original Java
<code className="jarombek-inline-code">Date</code> class<sup>9, 10</sup>.
</p>
<p>
Luckily, the date and time API used in pandas is easy to understand and use.  To use dates in a pandas
<code className="jarombek-inline-code">DataFrame</code> or <code className="jarombek-inline-code">Series</code>,
native Python <code className="jarombek-inline-code">datetime.datetime</code> objects are used.
</p>
<CodeSnippet language="Python">

</CodeSnippet>
<SectionTitle title="Advanced Data Manipulation with Group By">Advanced Data Manipulation with Group By</SectionTitle>
<SectionTitle title="Conclusions">Conclusions</SectionTitle>
</div>
